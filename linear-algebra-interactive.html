<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>工程數學二 — 線性代數互動教學</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;600;700;800&family=Playfair+Display:wght@700;800;900&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#1a1814;--card:rgba(255,255,255,0.03);--card2:rgba(255,255,255,0.05);
  --border:rgba(255,255,255,0.07);--border2:rgba(255,255,255,0.12);
  --text:#f0ead6;--text2:#c8c0b0;--text3:#8a8070;--text4:#5c4a3a;
  --teal:#2d7d9a;--purple:#a855f7;--gold:#e8b339;--tan:#d4a574;
  --red:#e05555;--green:#3ba55d;--blue:#5b9bd5;
  --nav-w:240px;
}
body{min-height:100vh;background:var(--bg);color:var(--text);font-family:'Noto Sans TC',sans-serif;font-size:15px;line-height:1.85}
::-webkit-scrollbar{width:5px}::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.1);border-radius:3px}
@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
button{font-family:inherit;cursor:pointer}
.layout{display:flex;min-height:100vh}
.sidebar{
  width:var(--nav-w);min-height:100vh;position:fixed;left:0;top:0;
  background:rgba(20,18,14,.97);border-right:1px solid var(--border);
  padding:20px 0;overflow-y:auto;z-index:100;
  backdrop-filter:blur(12px);transition:transform .3s;
}
.sidebar-header{padding:0 18px 16px;border-bottom:1px solid var(--border)}
.sidebar-header h1{
  font-size:16px;font-weight:800;font-family:'Playfair Display',serif;
  background:linear-gradient(135deg,var(--text),var(--tan));
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:3px;
}
.sidebar-header .sub{font-size:11px;color:var(--text3);font-weight:400}
.nav-group{padding:10px 0}
.nav-group-title{font-size:10px;font-weight:700;color:var(--text4);letter-spacing:.12em;text-transform:uppercase;padding:0 18px;margin-bottom:4px}
.nav-item{display:flex;align-items:center;gap:10px;padding:9px 18px;cursor:pointer;transition:all .2s;font-size:13px;color:var(--text3);border-left:3px solid transparent}
.nav-item:hover{color:var(--text2);background:rgba(255,255,255,.03)}
.nav-item.active{color:var(--gold);background:rgba(232,179,57,.06);border-left-color:var(--gold);font-weight:700}
.nav-item .num{font-family:'JetBrains Mono',monospace;font-size:11px;color:var(--text4);width:28px;flex-shrink:0}
.hamburger{display:none;position:fixed;top:14px;left:14px;z-index:200;background:rgba(30,27,22,.95);border:1px solid var(--border);border-radius:10px;padding:10px 13px;cursor:pointer;color:var(--text2);font-size:18px}
@media(max-width:800px){.sidebar{transform:translateX(-100%)}.sidebar.open{transform:translateX(0)}.hamburger{display:block}.main{margin-left:0!important;padding:20px!important;padding-top:56px!important}}
.main{margin-left:var(--nav-w);padding:36px 40px 60px;max-width:860px;margin-right:auto;width:calc(100% - var(--nav-w))}
@media(min-width:1200px){.main{margin-left:calc(var(--nav-w) + (100% - var(--nav-w) - 860px)/2)}}
.section{display:none;animation:fadeIn .3s ease}.section.active{display:block}
.section-tag{display:inline-block;padding:4px 14px;border-radius:20px;background:rgba(45,125,154,0.15);color:var(--teal);font-size:12px;font-weight:700;letter-spacing:2px;margin-bottom:10px;font-family:'JetBrains Mono',monospace}
.section-title{font-size:28px;font-weight:900;font-family:'Playfair Display',serif;background:linear-gradient(135deg,var(--text),var(--tan));-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:4px}
.section-sub{font-size:14px;color:var(--text3);margin-bottom:28px}
.card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:20px 22px;margin-bottom:16px}
.card-title{font-size:17px;font-weight:800;font-family:'Playfair Display',serif;margin-bottom:10px;color:var(--text)}
.card-title .en{font-size:12px;color:var(--text3);font-family:'JetBrains Mono',monospace;margin-left:8px;font-weight:400}
.def-box{background:rgba(45,125,154,0.08);border:1px solid rgba(45,125,154,0.2);border-radius:10px;padding:14px 18px;margin:12px 0}
.def-box .label{font-size:11px;font-weight:700;color:var(--teal);letter-spacing:1px;margin-bottom:6px}
.thm-box{background:rgba(168,85,247,0.08);border:1px solid rgba(168,85,247,0.2);border-radius:10px;padding:14px 18px;margin:12px 0}
.thm-box .label{font-size:11px;font-weight:700;color:var(--purple);letter-spacing:1px;margin-bottom:6px}
.prop-box{background:rgba(232,179,57,0.08);border:1px solid rgba(232,179,57,0.2);border-radius:10px;padding:14px 18px;margin:12px 0}
.prop-box .label{font-size:11px;font-weight:700;color:var(--gold);letter-spacing:1px;margin-bottom:6px}
.ex-box{background:rgba(59,165,93,0.08);border:1px solid rgba(59,165,93,0.2);border-radius:10px;padding:14px 18px;margin:12px 0}
.ex-box .label{font-size:11px;font-weight:700;color:var(--green);letter-spacing:1px;margin-bottom:6px}
.note-box{background:rgba(212,165,116,0.08);border:1px solid rgba(212,165,116,0.2);border-radius:10px;padding:14px 18px;margin:12px 0}
.note-box .label{font-size:11px;font-weight:700;color:var(--tan);letter-spacing:1px;margin-bottom:6px}
.formula-block{background:rgba(0,0,0,0.2);border-radius:10px;padding:16px;margin:12px 0;text-align:center;overflow-x:auto}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
@media(max-width:600px){.grid-2{grid-template-columns:1fr}}
.type-card{background:var(--card2);border:1px solid var(--border);border-radius:10px;padding:14px 16px;text-align:center}
.type-card .name{font-size:15px;font-weight:700;margin-bottom:2px}
.type-card .en{font-size:11px;color:var(--text3);font-family:'JetBrains Mono',monospace;margin-bottom:8px}
.prop-list{list-style:none;padding:0;margin:8px 0}
.prop-list li{padding:6px 0;border-bottom:1px solid var(--border);color:var(--text2);font-size:14px}
.prop-list li:last-child{border-bottom:none}
.interactive-box{background:rgba(0,0,0,0.15);border:1px solid var(--border2);border-radius:12px;padding:18px;margin:14px 0}
.interactive-box h4{font-size:14px;font-weight:700;color:var(--teal);margin-bottom:10px}
.mat-input{display:inline-grid;gap:4px;margin:8px}
.mat-input input{width:52px;height:36px;text-align:center;border:1px solid var(--border2);border-radius:6px;background:rgba(255,255,255,0.04);color:var(--text);font-family:'JetBrains Mono',monospace;font-size:14px}
.mat-input input:focus{outline:none;border-color:var(--teal);background:rgba(45,125,154,0.1)}
.btn{display:inline-block;padding:8px 20px;border-radius:8px;border:none;font-size:13px;font-weight:700;cursor:pointer;transition:all .2s}
.btn-teal{background:rgba(45,125,154,0.2);color:var(--teal)}.btn-teal:hover{background:rgba(45,125,154,0.35)}
.btn-gold{background:rgba(232,179,57,0.2);color:var(--gold)}.btn-gold:hover{background:rgba(232,179,57,0.35)}
.btn-purple{background:rgba(168,85,247,0.2);color:var(--purple)}.btn-purple:hover{background:rgba(168,85,247,0.35)}
.result-box{background:rgba(0,0,0,0.25);border-radius:8px;padding:12px 16px;margin-top:10px;min-height:40px;font-family:'JetBrains Mono',monospace;font-size:14px;color:var(--text2)}
.step-nav{display:flex;gap:6px;justify-content:center;margin:14px 0}
.step-dot{width:10px;height:10px;border-radius:50%;background:var(--border2);cursor:pointer;transition:all .2s}
.step-dot.active{background:var(--teal);transform:scale(1.3)}
.step-content{min-height:60px;padding:10px 0}
.footer{text-align:center;margin-top:36px;padding:14px 0;border-top:1px solid var(--border);color:var(--text4);font-size:11px;font-family:'JetBrains Mono',monospace}
.katex{font-size:1.05em!important}.katex-display{margin:10px 0!important;overflow-x:auto;overflow-y:hidden}
.anim-canvas{width:100%;background:rgba(0,0,0,0.2);border-radius:12px;border:1px solid var(--border2);cursor:crosshair;display:block;margin:12px 0}
.anim-controls{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0;align-items:center}
.btn-sm{padding:6px 14px;font-size:12px}
</style>
</head>
<body>
<button class="hamburger" onclick="document.querySelector('.sidebar').classList.toggle('open')">☰</button>
<div class="layout">
<nav class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <a href="index.html" style="display:flex;align-items:center;gap:6px;color:var(--text3);font-size:12px;text-decoration:none;margin-bottom:10px;padding:5px 0;transition:color .2s" onmouseover="this.style.color='var(--gold)'" onmouseout="this.style.color='var(--text3)'">← 返回首頁</a>
    <h1>線性代數</h1><div class="sub">工程數學二 互動教學</div>
  </div>
  <div class="nav-group">
    <div class="nav-group-title">Chapter 7 矩陣與線性系統</div>
    <div class="nav-item active" onclick="go('sec-71')"><span class="num">01</span>矩陣與向量</div>
    <div class="nav-item" onclick="go('sec-72')"><span class="num">02</span>矩陣乘法</div>
    <div class="nav-item" onclick="go('sec-73')"><span class="num">03</span>高斯消去法</div>
    <div class="nav-item" onclick="go('sec-77')"><span class="num">04</span>行列式</div>
    <div class="nav-item" onclick="go('sec-78')"><span class="num">05</span>反矩陣</div>
    <div class="nav-item" onclick="go('sec-74')"><span class="num">06</span>向量空間與線性獨立</div>
    <div class="nav-item" onclick="go('sec-lt')"><span class="num">07</span>線性轉換</div>
  </div>
  <div class="nav-group">
    <div class="nav-group-title">Chapter 8 特徵值問題</div>
    <div class="nav-item" onclick="go('sec-81')"><span class="num">08</span>特徵值與特徵向量</div>
    <div class="nav-item" onclick="go('sec-diag')"><span class="num">09</span>矩陣對角化</div>
    <div class="nav-item" onclick="go('sec-83')"><span class="num">10</span>對稱矩陣</div>
    <div class="nav-item" onclick="go('sec-qf')"><span class="num">11</span>二次式</div>
  </div>
</nav>
<div class="main" id="main-content">

<!-- ===== §7.1 矩陣與向量 ===== -->
<div class="section active" id="sec-71">
  <div class="section-tag">01</div>
  <div class="section-title">矩陣與向量</div>
  <div class="section-sub">Matrices, Vectors: Addition and Scalar Multiplication</div>
  <div class="card">
    <div class="card-title">線性代數簡介</div>
    <p style="color:var(--text2)">線性代數的核心目標是求解線性方程組 \(\mathbf{A}\mathbf{x} = \mathbf{b}\)。矩陣是線性代數最基本的工具，用以有系統地表達與操作線性方程組。</p>
    <div class="def-box"><div class="label">DEFINITION — 矩陣</div>
      <p>一個 \(m \times n\) 矩陣是由 \(m\) 列（rows）、\(n\) 行（columns）排列而成的矩形數組：</p>
      <div class="formula-block">$$[A]_{m \times n} = \begin{bmatrix} a_{11} & a_{12} & \cdots & a_{1n} \\ a_{21} & a_{22} & \cdots & a_{2n} \\ \vdots & \vdots & \ddots & \vdots \\ a_{m1} & a_{m2} & \cdots & a_{mn} \end{bmatrix} = [a_{ij}]$$</div>
      <p>其中 \(a_{ij}\) 表示第 \(i\) 列、第 \(j\) 行的元素。</p>
    </div>
  </div>
  <div class="card">
    <div class="card-title">矩陣基本分類<span class="en">Types of Matrices</span></div>
    <div class="grid-2">
      <div class="type-card"><div class="name">① 列矩陣</div><div class="en">Row Matrix (1×n)</div>
        <div class="formula-block">$$\begin{bmatrix} a_1 & a_2 & \cdots & a_n \end{bmatrix}$$</div></div>
      <div class="type-card"><div class="name">② 行矩陣</div><div class="en">Column Matrix (m×1)</div>
        <div class="formula-block">$$\begin{bmatrix} a_1 \\ a_2 \\ \vdots \\ a_m \end{bmatrix}$$</div></div>
      <div class="type-card"><div class="name">③ 方矩陣</div><div class="en">Square Matrix (m = n)</div>
        <p style="font-size:13px;color:var(--text2);margin-top:4px">列數等於行數，主對角線元素為 \(a_{11}, a_{22}, \ldots, a_{nn}\)</p></div>
      <div class="type-card"><div class="name">④ 單位矩陣</div><div class="en">Identity Matrix I</div>
        <div class="formula-block">$$I = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$</div></div>
      <div class="type-card"><div class="name">⑤ 對角線矩陣</div><div class="en">Diagonal Matrix</div>
        <div class="formula-block">$$D = \begin{bmatrix} d_1 & 0 & 0 \\ 0 & d_2 & 0 \\ 0 & 0 & d_3 \end{bmatrix}$$</div></div>
      <div class="type-card"><div class="name">⑥ 上三角矩陣</div><div class="en">Upper Triangular</div>
        <div class="formula-block">$$\begin{bmatrix} u_{11} & u_{12} & u_{13} \\ 0 & u_{22} & u_{23} \\ 0 & 0 & u_{33} \end{bmatrix}$$</div></div>
      <div class="type-card" style="grid-column:1/-1"><div class="name">⑦ 下三角矩陣</div><div class="en">Lower Triangular</div>
        <div class="formula-block">$$\begin{bmatrix} l_{11} & 0 & 0 \\ l_{21} & l_{22} & 0 \\ l_{31} & l_{32} & l_{33} \end{bmatrix}$$</div></div>
    </div>
  </div>
  <div class="card">
    <div class="card-title">矩陣相等<span class="en">Matrix Equality</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>\(A = B\) 若且唯若：兩者大小相同（皆為 \(m \times n\)），且 \(a_{ij} = b_{ij}\) 對所有 \(i, j\) 成立。</p></div>
  </div>
  <div class="card">
    <div class="card-title">矩陣加法<span class="en">Matrix Addition</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>兩個大小相同的 \(m \times n\) 矩陣，其和定義為：\(A + B = [a_{ij} + b_{ij}]\)</p></div>
    <div class="prop-box"><div class="label">PROPERTIES</div>
      <ul class="prop-list">
        <li>① 交換律：\(A + B = B + A\)</li>
        <li>② 結合律：\((A + B) + C = A + (B + C)\)</li>
        <li>③ 零矩陣：\(A + O = A\)</li>
        <li>④ 加法反元素：\(A + (-A) = O\)</li>
      </ul></div>
  </div>
  <div class="card">
    <div class="card-title">常數與矩陣相乘<span class="en">Scalar Multiplication</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>純量 \(c\) 與矩陣 \(A\) 的積：\(cA = [c \cdot a_{ij}]\)</p></div>
    <div class="prop-box"><div class="label">PROPERTIES</div>
      <ul class="prop-list">
        <li>① \(c(A + B) = cA + cB\)</li>
        <li>② \((c + k)A = cA + kA\)</li>
        <li>③ \(c(kA) = (ck)A\)</li>
      </ul></div>
  </div>
  <div class="card">
    <div class="card-title">矩陣轉置<span class="en">Transpose</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>\(A^T\) 定義為將列與行互換：\((A^T)_{ij} = a_{ji}\)。若 \(A\) 為 \(m \times n\)，則 \(A^T\) 為 \(n \times m\)。</p></div>
    <div class="prop-box"><div class="label">PROPERTIES</div>
      <ul class="prop-list">
        <li>① \((A^T)^T = A\)</li>
        <li>② \((A + B)^T = A^T + B^T\)</li>
        <li>③ \((cA)^T = cA^T\)</li>
        <li>④ \((AB)^T = B^T A^T\)</li>
      </ul></div>
    <div class="note-box"><div class="label">特殊矩陣</div>
      <ul class="prop-list">
        <li><strong style="color:var(--teal)">對稱矩陣 Symmetric：</strong>\(A^T = A\)</li>
        <li><strong style="color:var(--purple)">反對稱矩陣 Skew-Symmetric：</strong>\(A^T = -A\)（主對角線元素皆為 0）</li>
        <li><strong style="color:var(--gold)">正交矩陣 Orthogonal：</strong>\(A^T A = AA^T = I\)</li>
      </ul></div>
  </div>
  <div class="card">
    <div class="card-title">範例 <span class="en">Example</span></div>
    <div class="ex-box"><div class="label">EXAMPLE</div>
      <p>設 \(A = \begin{bmatrix}1&2&3\\4&5&6\end{bmatrix}\)，\(B = \begin{bmatrix}0&1&-1\\2&-3&4\end{bmatrix}\)，求 \(2A - 3B\) 及 \(A^T\)。</p>
      <p><strong>解</strong>：</p>
      <div class="formula-block">$$2A - 3B = \begin{bmatrix}2&4&6\\8&10&12\end{bmatrix} - \begin{bmatrix}0&3&-3\\6&-9&12\end{bmatrix} = \begin{bmatrix}2&1&9\\2&19&0\end{bmatrix}$$</div>
      <div class="formula-block">$$A^T = \begin{bmatrix}1&4\\2&5\\3&6\end{bmatrix}$$</div>
    </div>
  </div>
  <div class="card">
    <div class="card-title">動畫展示 <span class="en">Animation</span></div>
    <div style="text-align:center">
      <canvas id="cv-matvec" width="760" height="360" style="background:#1b1b2f;border-radius:10px;max-width:100%"></canvas>
      <div style="font-size:11px;color:var(--text3);margin-top:6px">向量加法：平行四邊形法則 a + b = c</div>
    </div>
  </div>
  <div class="card">
    <div class="card-title">互動工具：轉置計算器</div>
    <div class="interactive-box"><h4>輸入 2×3 矩陣，即時計算轉置</h4>
      <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap">
        <div><div style="font-size:12px;color:var(--text3);margin-bottom:4px">A (2×3)</div>
          <div class="mat-input" id="trans-in" style="grid-template-columns:repeat(3,1fr)">
            <input value="1" oninput="calcTranspose()"><input value="2" oninput="calcTranspose()"><input value="3" oninput="calcTranspose()">
            <input value="4" oninput="calcTranspose()"><input value="5" oninput="calcTranspose()"><input value="6" oninput="calcTranspose()">
          </div></div>
        <div style="font-size:24px;color:var(--text3)">→</div>
        <div><div style="font-size:12px;color:var(--text3);margin-bottom:4px">A<sup>T</sup> (3×2)</div>
          <div id="trans-out" class="result-box" style="min-width:120px"></div></div>
      </div>
    </div>
  </div>
</div>

<!-- ===== §7.2 矩陣乘法 ===== -->
<div class="section" id="sec-72">
  <div class="section-tag">02</div>
  <div class="section-title">矩陣乘法</div>
  <div class="section-sub">Matrix Multiplication</div>
  <div class="card">
    <div class="card-title">矩陣乘法定義<span class="en">Definition</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>設 \(A\) 為 \(m \times r\)，\(B\) 為 \(r \times n\)，則 \(C = AB\) 為 \(m \times n\) 矩陣：</p>
      <div class="formula-block">$$c_{ij} = \sum_{k=1}^{r} a_{ik}\,b_{kj}$$</div>
      <p>維度規則：\(\underset{m \times \boxed{r}}{A} \;\cdot\; \underset{\boxed{r} \times n}{B} = \underset{m \times n}{C}\)，A 的行數必須等於 B 的列數。</p></div>
    <div class="ex-box"><div class="label">EXAMPLE</div>
      <div class="formula-block">$$\begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}\begin{bmatrix} 1 & 4 \\ 2 & 5 \\ 3 & 6 \end{bmatrix} = \begin{bmatrix} 14 & 32 \\ 32 & 77 \end{bmatrix}$$</div>
      <p style="font-size:13px;color:var(--text3)">\((2 \times 3)(3 \times 2) = (2 \times 2)\)</p></div>
  </div>
  <div class="card">
    <div class="card-title">矩陣乘法基本性質<span class="en">Properties</span></div>
    <div class="prop-box"><div class="label">PROPERTIES</div>
      <ul class="prop-list">
        <li>① \((cA)B = c(AB) = A(cB)\)</li>
        <li>② 結合律：\((AB)C = A(BC)\)</li>
        <li>③ 分配律：\(A(B + C) = AB + AC\)</li>
        <li>④ 分配律：\((A + B)C = AC + BC\)</li>
        <li>⑤ <strong style="color:var(--red)">不可交換：一般而言 \(AB \neq BA\)</strong></li>
      </ul></div>
    <div class="note-box"><div class="label">重要公式</div>
      <ul class="prop-list">
        <li>\((AB)^T = B^T A^T\)</li>
        <li>單位矩陣：\(AI = IA = A\)</li>
      </ul></div>
  </div>
  <div class="card">
    <div class="card-title">動畫展示 <span class="en">Animation</span></div>
    <div style="text-align:center">
      <canvas id="cv-matmul" width="760" height="360" style="background:#1b1b2f;border-radius:10px;max-width:100%"></canvas>
      <div style="font-size:11px;color:var(--text3);margin-top:6px">矩陣乘法：行列點積動畫，結果矩陣逐元素產生</div>
    </div>
  </div>
  <div class="card">
    <div class="card-title">互動工具：矩陣乘法計算器</div>
    <div class="interactive-box"><h4>輸入兩個 2×2 矩陣，計算 AB 與 BA（含詳細步驟）</h4>
      <div style="display:flex;align-items:center;gap:16px;flex-wrap:wrap">
        <div><div style="font-size:12px;color:var(--text3);margin-bottom:4px">A</div>
          <div class="mat-input" id="mul-a" style="grid-template-columns:1fr 1fr">
            <input value="1" oninput="calcMul()"><input value="2" oninput="calcMul()">
            <input value="3" oninput="calcMul()"><input value="4" oninput="calcMul()"></div></div>
        <div style="font-size:20px;color:var(--text3)">×</div>
        <div><div style="font-size:12px;color:var(--text3);margin-bottom:4px">B</div>
          <div class="mat-input" id="mul-b" style="grid-template-columns:1fr 1fr">
            <input value="5" oninput="calcMul()"><input value="6" oninput="calcMul()">
            <input value="7" oninput="calcMul()"><input value="8" oninput="calcMul()"></div></div>
        <div style="font-size:20px;color:var(--text3)">=</div>
        <div><div style="font-size:12px;color:var(--text3);margin-bottom:4px">AB</div>
          <div id="mul-out" class="result-box" style="min-width:120px"></div></div>
      </div>
      <div id="mul-steps" class="result-box" style="margin-top:12px;line-height:2"></div>
      <div style="margin-top:12px"><div style="font-size:12px;color:var(--text3);margin-bottom:4px">BA =（驗證 AB ≠ BA）</div>
        <div id="mul-out-ba" class="result-box"></div></div>
      <div id="mul-steps-ba" class="result-box" style="margin-top:8px;line-height:2"></div>
      <div id="mul-compare" style="margin-top:10px;padding:10px 14px;border-radius:8px;font-size:13px"></div>
    </div>
  </div>
</div>

<!-- ===== §7.3 高斯消去法 ===== -->
<div class="section" id="sec-73">
  <div class="section-tag">03</div>
  <div class="section-title">高斯消去法</div>
  <div class="section-sub">Linear Systems of Equations, Gauss Elimination</div>

  <div class="card">
    <div class="card-title">增廣矩陣<span class="en">Augmented Matrix</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>線性方程組 \(A\mathbf{x} = \mathbf{b}\) 可表示為增廣矩陣：</p>
      <div class="formula-block">$$[\,A\,|\,\mathbf{b}\,] = \left[\begin{array}{ccc|c} a_{11} & \cdots & a_{1n} & b_1 \\ \vdots & \ddots & \vdots & \vdots \\ a_{m1} & \cdots & a_{mn} & b_m \end{array}\right]$$</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">基本列操作<span class="en">Elementary Row Operations</span></div>
    <div class="def-box"><div class="label">三種基本列操作</div>
      <ul class="prop-list">
        <li>① <strong style="color:var(--teal)">交換兩列：</strong>\(R_i \leftrightarrow R_j\)</li>
        <li>② <strong style="color:var(--purple)">列乘以非零常數：</strong>\(cR_i\)（\(c \neq 0\)）</li>
        <li>③ <strong style="color:var(--gold)">列加上另一列的倍數：</strong>\(R_i + cR_j\)</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title">列梯式與化簡列梯式<span class="en">Row Echelon Form</span></div>
    <div class="def-box"><div class="label">ROW ECHELON FORM (REF)</div>
      <ul class="prop-list">
        <li>① 全零列（若有）在矩陣最下方</li>
        <li>② 每一列的首非零元素（leading entry）位於上一列首非零元素的右邊</li>
        <li>③ 首非零元素下方的元素皆為 0</li>
      </ul>
    </div>
    <div class="def-box"><div class="label">REDUCED ROW ECHELON FORM (RREF)</div>
      <p>在 REF 的基礎上，額外要求：</p>
      <ul class="prop-list">
        <li>④ 每列的首非零元素為 1（leading 1）</li>
        <li>⑤ 每個 leading 1 所在行的其他元素皆為 0</li>
      </ul>
    </div>
    <div class="ex-box"><div class="label">EXAMPLE — Gauss-Jordan 消去</div>
      <div class="formula-block">$$\begin{bmatrix} 1 & 2 & -1 & | & 3 \\ 2 & 5 & 0 & | & 8 \\ 3 & 7 & -1 & | & 11 \end{bmatrix}$$</div>
      <p style="color:var(--text2);font-size:13px">\(R_2 - 2R_1,\; R_3 - 3R_1\) → \(R_3 - R_2\) → 回代求得唯一解</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">Rank 與解的分類<span class="en">Rank and Solution Classification</span></div>
    <div class="def-box"><div class="label">DEFINITION — Rank（秩）</div>
      <p>矩陣化為列梯式後，非零列的數目即為矩陣的秩 \(r(A)\)（或 \(\text{rank}(A)\)）。</p>
    </div>
    <div class="thm-box"><div class="label">THEOREM — 線性系統解的分類（n 個未知數）</div>
      <ul class="prop-list">
        <li>① <strong style="color:var(--green)">唯一解：</strong>\(r(A) = r([A|\mathbf{b}]) = n\)</li>
        <li>② <strong style="color:var(--blue)">無窮多解：</strong>\(r(A) = r([A|\mathbf{b}]) < n\)（自由變數 = \(n - r\) 個）</li>
        <li>③ <strong style="color:var(--red)">無解（矛盾）：</strong>\(r(A) \neq r([A|\mathbf{b}])\)（出現 \([0\;0\;\cdots\;0\;|\;c]\)，\(c \neq 0\)）</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title">高斯消去法動畫工具</div>
    <div class="interactive-box">
      <h4>增廣矩陣動畫展示</h4>
      <div style="display:flex;gap:4px;flex-wrap:wrap;align-items:center">
        <div class="mat-input" id="gauss-anim-in" style="grid-template-columns:repeat(4,1fr)">
          <input value="1"><input value="2"><input value="-1"><input value="3">
          <input value="2"><input value="5"><input value="0"><input value="8">
          <input value="3"><input value="7"><input value="-1"><input value="11">
        </div>
        <div style="font-size:11px;color:var(--text3);writing-mode:vertical-rl">← [A|b]</div>
      </div>
      <div class="anim-controls">
        <button class="btn btn-teal btn-sm" onclick="gaussAnimStep()">下一步</button>
        <button class="btn btn-teal btn-sm" onclick="gaussAnimAuto()">自動播放</button>
        <button class="btn btn-teal btn-sm" onclick="gaussAnimReset()">重置</button>
      </div>
      <canvas id="gauss-anim-canvas" class="anim-canvas" height="350" style="background:#1b1b2f"></canvas>
      <div id="gauss-anim-info" class="result-box" style="margin-top:10px;font-size:12px;background:rgba(27,27,47,0.6);border:1px solid rgba(88,196,221,0.2)"></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">互動工具：3×3 高斯消去</div>
    <div class="interactive-box">
      <h4>輸入增廣矩陣 [A|b]，逐步執行高斯消去</h4>
      <div style="display:flex;gap:4px;flex-wrap:wrap;align-items:center">
        <div class="mat-input" id="gauss-in" style="grid-template-columns:repeat(4,1fr)">
          <input value="1"><input value="2"><input value="-1"><input value="3">
          <input value="2"><input value="5"><input value="0"><input value="8">
          <input value="3"><input value="7"><input value="-1"><input value="11">
        </div>
        <div style="font-size:11px;color:var(--text3);writing-mode:vertical-rl">← [A|b]</div>
      </div>
      <button class="btn btn-teal" style="margin-top:10px" onclick="runGauss()">執行高斯消去</button>
      <div id="gauss-steps" class="result-box" style="margin-top:10px;white-space:pre-wrap;max-height:400px;overflow-y:auto"></div>
    </div>
  </div>
</div>

<!-- ===== §7.4 向量空間與線性獨立 ===== -->
<div class="section" id="sec-74">
  <div class="section-tag">06</div>
  <div class="section-title">向量空間與線性獨立</div>
  <div class="section-sub">Vector Space, Linear Independence, Rank of a Matrix</div>

  <div class="card">
    <div class="card-title">向量空間<span class="en">Vector Space</span></div>
    <div class="def-box"><div class="label">DEFINITION — Span（生成空間）</div>
      <p>向量 \(\mathbf{v}_1, \mathbf{v}_2, \ldots, \mathbf{v}_k\) 的所有線性組合所成的集合：</p>
      <div class="formula-block">$$\text{Span}\{\mathbf{v}_1, \ldots, \mathbf{v}_k\} = \{c_1\mathbf{v}_1 + c_2\mathbf{v}_2 + \cdots + c_k\mathbf{v}_k \;|\; c_i \in \mathbb{R}\}$$</div>
    </div>
    <div class="def-box"><div class="label">DEFINITION — Basis（基底）與 Dimension（維度）</div>
      <p><strong>基底：</strong>向量空間 \(V\) 的一組基底是一組線性獨立的向量，且能生成整個 \(V\)。</p>
      <p><strong>維度：</strong>\(\dim(V)\) = 基底中向量的個數。</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">線性獨立<span class="en">Linear Independence</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>若 \(c_1\mathbf{v}_1 + c_2\mathbf{v}_2 + \cdots + c_k\mathbf{v}_k = \mathbf{0}\) 只有平凡解 \(c_1 = c_2 = \cdots = c_k = 0\)，則 \(\{\mathbf{v}_1, \ldots, \mathbf{v}_k\}\) 線性獨立。</p>
    </div>
    <div class="note-box"><div class="label">線性獨立判斷方法</div>
      <ul class="prop-list">
        <li>方法一：將向量排成矩陣 \(A\)，若 \(\det(A) \neq 0\) → 線性獨立</li>
        <li>方法二：將向量排成矩陣 \(A\)，若 \(\text{rank}(A) = k\)（向量個數）→ 線性獨立</li>
        <li>等價條件：齊次方程組 \(A\mathbf{x} = \mathbf{0}\) 只有零解 → 線性獨立</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title">向量空間 Span 動畫</div>
    <div class="interactive-box">
      <h4>拖動 <span style="color:#83c167">v₁</span> 和 <span style="color:#fc6255">v₂</span> 的端點，觀察 Span 如何改變</h4>
      <canvas id="span-canvas" class="anim-canvas" height="450" style="background:#1b1b2f"></canvas>
      <div class="anim-controls" style="margin-top:14px">
        <div style="flex:1;min-width:200px">
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
            <span style="color:#83c167;font-weight:700;font-size:13px;width:28px">c₁</span>
            <input type="range" id="span-c1" min="-3" max="3" step="0.05" value="1" style="flex:1;accent-color:#83c167" oninput="updateSpan()">
            <span id="span-c1-val" style="color:#83c167;font-family:'JetBrains Mono';font-size:13px;width:40px;text-align:right">1.00</span>
          </div>
          <div style="display:flex;align-items:center;gap:8px">
            <span style="color:#fc6255;font-weight:700;font-size:13px;width:28px">c₂</span>
            <input type="range" id="span-c2" min="-3" max="3" step="0.05" value="1" style="flex:1;accent-color:#fc6255" oninput="updateSpan()">
            <span id="span-c2-val" style="color:#fc6255;font-family:'JetBrains Mono';font-size:13px;width:40px;text-align:right">1.00</span>
          </div>
        </div>
        <div style="display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn btn-teal btn-sm" onclick="spanAnimateToTarget()">播放組合</button>
          <button class="btn btn-sm" onclick="spanFillPlane()" style="background:linear-gradient(135deg,rgba(131,193,103,0.3),rgba(252,98,85,0.3));color:#ffff00;font-weight:700;border:1px solid rgba(255,255,0,0.3)">鋪滿平面 ✦</button>
          <button class="btn btn-gold btn-sm" onclick="spanResetVectors()">重置</button>
          <button class="btn btn-purple btn-sm" onclick="spanSetDependent()">線性相依</button>
        </div>
      </div>
      <div id="span-info" class="result-box" style="margin-top:10px;font-size:13px;background:rgba(27,27,47,0.6);border:1px solid rgba(131,193,103,0.2)"></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">列空間、行空間、零空間<span class="en">Row / Column / Null Space</span></div>
    <div class="def-box"><div class="label">DEFINITIONS</div>
      <ul class="prop-list">
        <li><strong style="color:var(--teal)">列空間 Row Space：</strong>\(A\) 的各列所生成的空間</li>
        <li><strong style="color:var(--purple)">行空間 Column Space：</strong>\(A\) 的各行所生成的空間 = \(\{A\mathbf{x} \;|\; \mathbf{x} \in \mathbb{R}^n\}\)</li>
        <li><strong style="color:var(--gold)">零空間 Null Space：</strong>\(N(A) = \{\mathbf{x} \;|\; A\mathbf{x} = \mathbf{0}\}\)</li>
      </ul>
    </div>
    <div class="thm-box"><div class="label">THEOREM — Rank-Nullity 定理</div>
      <div class="formula-block">$$\text{rank}(A) + \text{nullity}(A) = n$$</div>
      <p>其中 \(n\) 為行數（未知數個數），\(\text{nullity}(A) = \dim(N(A))\)。</p>
    </div>
    <div class="ex-box"><div class="label">EXAMPLE</div>
      <p>求下列矩陣的 Row Space、Column Space、Null Space：</p>
      <div class="formula-block">$$A = \begin{bmatrix} 1 & 2 & 1 \\ 2 & 4 & 3 \\ 3 & 6 & 4 \end{bmatrix} \xrightarrow{\text{REF}} \begin{bmatrix} 1 & 2 & 1 \\ 0 & 0 & 1 \\ 0 & 0 & 0 \end{bmatrix}$$</div>
      <p style="color:var(--text2);font-size:13px">\(\text{rank}(A) = 2\)，\(\text{nullity}(A) = 3 - 2 = 1\)</p>
      <p style="color:var(--text2);font-size:13px">Row Space 基底：\(\{[1,2,1],\;[0,0,1]\}\)，Null Space 基底：\(\{[-2,1,0]^T\}\)</p>
    </div>
  </div>
</div>

<!-- ===== §7.7 行列式 ===== -->
<div class="section" id="sec-77">
  <div class="section-tag">04</div>
  <div class="section-title">行列式</div>
  <div class="section-sub">Determinants, Cramer's Rule</div>

  <div class="card">
    <div class="card-title">行列式定義<span class="en">Determinant</span></div>
    <div class="def-box"><div class="label">DEFINITION — 2×2 行列式</div>
      <div class="formula-block">$$\det(A) = \begin{vmatrix} a & b \\ c & d \end{vmatrix} = ad - bc$$</div>
    </div>
    <div class="def-box"><div class="label">DEFINITION — 餘因子 Cofactor</div>
      <p>元素 \(a_{ij}\) 的餘因子：\(C_{ij} = (-1)^{i+j} M_{ij}\)，其中 \(M_{ij}\) 是刪去第 \(i\) 列第 \(j\) 行後的行列式（子式）。</p>
    </div>
    <div class="def-box"><div class="label">DEFINITION — n×n 行列式（沿第 i 列展開）</div>
      <div class="formula-block">$$\det(A) = \sum_{j=1}^{n} a_{ij} \cdot C_{ij} = \sum_{j=1}^{n} (-1)^{i+j}\, a_{ij}\, M_{ij}$$</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">行列式重要性質<span class="en">Properties</span></div>
    <div class="prop-box"><div class="label">9 大性質</div>
      <ul class="prop-list">
        <li>① \(\det(A^T) = \det(A)\)</li>
        <li>② 交換兩列 → 行列式變號</li>
        <li>③ 某列有公因子 \(c\) → 可提出 \(c\)</li>
        <li>④ 兩列相同 → \(\det = 0\)</li>
        <li>⑤ 某列全為零 → \(\det = 0\)</li>
        <li>⑥ 三角矩陣的行列式 = 主對角線元素乘積</li>
        <li>⑦ \(\det(kA) = k^n \det(A)\)（\(A\) 為 \(n \times n\)）</li>
        <li>⑧ \(\det(AB) = \det(A) \cdot \det(B)\)</li>
        <li>⑨ \(R_i + cR_j\) 不改變行列式值</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title">行列式與面積動畫</div>
    <div class="interactive-box">
      <h4>拖動向量端點，觀察平行四邊形面積（行列式）</h4>
      <canvas id="det-canvas" class="anim-canvas" height="450" style="background:#1b1b2f"></canvas>
      <div id="det-info" class="result-box" style="margin-top:10px;font-size:13px;font-weight:700;background:rgba(27,27,47,0.6);border:1px solid rgba(252,98,85,0.2)"></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">克拉莫法則<span class="en">Cramer's Rule</span></div>
    <div class="thm-box"><div class="label">THEOREM</div>
      <p>若 \(\det(A) \neq 0\)，則 \(A\mathbf{x} = \mathbf{b}\) 的唯一解為：</p>
      <div class="formula-block">$$x_i = \frac{\det(A_i)}{\det(A)}, \quad i = 1, 2, \ldots, n$$</div>
      <p>其中 \(A_i\) 是將 \(A\) 的第 \(i\) 行替換為 \(\mathbf{b}\) 所得的矩陣。</p>
    </div>
    <div class="ex-box"><div class="label">EXAMPLE</div>
      <p>解 \(\begin{cases} 2x_1 + x_2 = 5 \\ x_1 + 3x_2 = 5 \end{cases}\)</p>
      <div class="formula-block">$$\det(A) = \begin{vmatrix}2&1\\1&3\end{vmatrix}=5,\quad x_1 = \frac{\begin{vmatrix}5&1\\5&3\end{vmatrix}}{5} = \frac{10}{5} = 2,\quad x_2 = \frac{\begin{vmatrix}2&5\\1&5\end{vmatrix}}{5} = \frac{5}{5} = 1$$</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">互動工具：行列式計算器</div>
    <div class="interactive-box"><h4>2×2 行列式</h4>
      <div class="mat-input" id="det2-in" style="grid-template-columns:1fr 1fr">
        <input value="2" oninput="calcDet2()"><input value="1" oninput="calcDet2()">
        <input value="1" oninput="calcDet2()"><input value="3" oninput="calcDet2()">
      </div>
      <div id="det2-out" class="result-box"></div>
    </div>
    <div class="interactive-box" style="margin-top:12px"><h4>3×3 行列式（沿第一列展開）</h4>
      <div class="mat-input" id="det3-in" style="grid-template-columns:1fr 1fr 1fr">
        <input value="1" oninput="calcDet3()"><input value="2" oninput="calcDet3()"><input value="3" oninput="calcDet3()">
        <input value="4" oninput="calcDet3()"><input value="5" oninput="calcDet3()"><input value="6" oninput="calcDet3()">
        <input value="7" oninput="calcDet3()"><input value="8" oninput="calcDet3()"><input value="0" oninput="calcDet3()">
      </div>
      <div id="det3-out" class="result-box"></div>
    </div>
  </div>
</div>

<!-- ===== §7.8 反矩陣 ===== -->
<div class="section" id="sec-78">
  <div class="section-tag">05</div>
  <div class="section-title">反矩陣</div>
  <div class="section-sub">Inverse of a Matrix</div>

  <div class="card">
    <div class="card-title">反矩陣定義<span class="en">Definition</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>若方矩陣 \(A\) 存在一矩陣 \(A^{-1}\) 使得：</p>
      <div class="formula-block">$$AA^{-1} = A^{-1}A = I$$</div>
      <p>則稱 \(A\) 可逆（nonsingular），\(A^{-1}\) 為其反矩陣。存在條件：\(\det(A) \neq 0\)。</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">反矩陣性質<span class="en">Properties</span></div>
    <div class="prop-box"><div class="label">PROPERTIES</div>
      <ul class="prop-list">
        <li>① \((A^{-1})^{-1} = A\)</li>
        <li>② \((AB)^{-1} = B^{-1}A^{-1}\)</li>
        <li>③ \((A^T)^{-1} = (A^{-1})^T\)</li>
        <li>④ \((cA)^{-1} = \frac{1}{c}A^{-1}\)</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title">反矩陣求解方法</div>
    <div class="def-box"><div class="label">方法一：Gauss-Jordan 法</div>
      <p>構造增廣矩陣 \([A\,|\,I]\)，經列運算化簡為 \([I\,|\,A^{-1}]\)。</p>
      <div class="formula-block">$$[A\;|\;I] \xrightarrow{\text{Row Operations}} [I\;|\;A^{-1}]$$</div>
    </div>
    <div class="def-box"><div class="label">方法二：公式法（伴隨矩陣法）</div>
      <div class="formula-block">$$A^{-1} = \frac{1}{\det(A)} \text{adj}(A)$$</div>
      <p>其中 \(\text{adj}(A)\) 是餘因子矩陣的轉置：\(\text{adj}(A) = [C_{ij}]^T\)。</p>
    </div>
    <div class="note-box"><div class="label">2×2 反矩陣速算公式</div>
      <div class="formula-block">$$A = \begin{bmatrix}a&b\\c&d\end{bmatrix} \Rightarrow A^{-1} = \frac{1}{ad-bc}\begin{bmatrix}d&-b\\-c&a\end{bmatrix}$$</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">反矩陣求解線性方程組</div>
    <div class="thm-box"><div class="label">THEOREM</div>
      <p>若 \(A\) 可逆，則 \(A\mathbf{x} = \mathbf{b}\) 的唯一解為：</p>
      <div class="formula-block">$$\mathbf{x} = A^{-1}\mathbf{b}$$</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">範例 <span class="en">Example</span></div>
    <div class="ex-box"><div class="label">EXAMPLE</div>
      <p>求 \(A = \begin{bmatrix}2&1\\5&3\end{bmatrix}\) 的反矩陣。</p>
      <p><strong>解</strong>：\(\det(A) = 2(3)-1(5) = 1 \neq 0\)，故 \(A\) 可逆。</p>
      <div class="formula-block">$$A^{-1} = \frac{1}{1}\begin{bmatrix}3&-1\\-5&2\end{bmatrix} = \begin{bmatrix}3&-1\\-5&2\end{bmatrix}$$</div>
      <p style="color:var(--text2);font-size:14px">驗證：\(AA^{-1} = \begin{bmatrix}2&1\\5&3\end{bmatrix}\begin{bmatrix}3&-1\\-5&2\end{bmatrix} = \begin{bmatrix}1&0\\0&1\end{bmatrix} = I\) ✓</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">動畫展示 <span class="en">Animation</span></div>
    <div style="text-align:center">
      <canvas id="cv-inverse" width="760" height="360" style="background:#1b1b2f;border-radius:10px;max-width:100%"></canvas>
      <div style="font-size:11px;color:var(--text3);margin-top:6px">反矩陣的幾何意義：A 變換後再用 A⁻¹ 變換，回到原始狀態</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">互動工具：2×2 反矩陣計算器</div>
    <div class="interactive-box"><h4>輸入 2×2 矩陣，計算反矩陣</h4>
      <div class="mat-input" id="inv2-in" style="grid-template-columns:1fr 1fr">
        <input value="2" oninput="calcInv2()"><input value="1" oninput="calcInv2()">
        <input value="1" oninput="calcInv2()"><input value="3" oninput="calcInv2()">
      </div>
      <div id="inv2-out" class="result-box"></div>
    </div>
  </div>
</div>

<!-- ===== §8.1 特徵值與特徵向量 ===== -->
<div class="section" id="sec-81">
  <div class="section-tag">08</div>
  <div class="section-title">特徵值與特徵向量</div>
  <div class="section-sub">Eigenvalues, Eigenvectors</div>

  <div class="card">
    <div class="card-title">定義<span class="en">Definition</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>設 \(A\) 為 \(n \times n\) 方矩陣，若存在非零向量 \(\mathbf{x}\) 及純量 \(\lambda\) 使得：</p>
      <div class="formula-block">$$A\mathbf{x} = \lambda\mathbf{x}$$</div>
      <p>則 \(\lambda\) 稱為 \(A\) 的<strong>特徵值</strong>（eigenvalue），\(\mathbf{x}\) 為對應的<strong>特徵向量</strong>（eigenvector）。</p>
    </div>
    <div class="def-box"><div class="label">特徵方程式 Characteristic Equation</div>
      <div class="formula-block">$$\det(A - \lambda I) = 0$$</div>
      <p>此為 \(\lambda\) 的 \(n\) 次多項式方程，稱為特徵多項式。</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">特徵向量動畫</div>
    <div class="interactive-box">
      <h4>觀察：特徵向量被矩陣變換後只伸縮（Av = λv），方向不會改變</h4>
      <div style="margin-bottom:12px">
        <label style="color:var(--text2);margin-right:12px">矩陣選擇：
          <select id="eig-matrix-select" onchange="updateEigAnim()" style="background:rgba(255,255,255,0.1);color:var(--text);border:1px solid var(--border2);padding:4px 8px;border-radius:4px;font-family:inherit">
            <option value="sym" selected>對稱矩陣 [[2,1],[1,2]]</option>
            <option value="diag">對角矩陣 [[3,0],[0,-1]]</option>
            <option value="scale">縮放 [[2,0],[0,0.5]]</option>
            <option value="shear">剪切 [[1,0.5],[0,1]]</option>
            <option value="rot">旋轉 45°（複數特徵值）</option>
          </select>
        </label>
      </div>
      <canvas id="eig-canvas" class="anim-canvas" height="420" style="background:#1b1b2f"></canvas>
      <div class="anim-controls">
        <button class="btn btn-purple btn-sm" onclick="eigAnimTransform()">播放</button>
        <button class="btn btn-purple btn-sm" onclick="eigAnimReset()">重置</button>
      </div>
      <div id="eig-info" class="result-box" style="margin-top:10px;font-size:13px;background:rgba(27,27,47,0.6);border:1px solid rgba(180,142,173,0.2)"></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">求解步驟</div>
    <div class="note-box"><div class="label">PROCEDURE</div>
      <ul class="prop-list">
        <li>Step 1：列出 \(\det(A - \lambda I) = 0\)，解出所有 \(\lambda\)</li>
        <li>Step 2：對每個 \(\lambda\)，解 \((A - \lambda I)\mathbf{x} = \mathbf{0}\)，求特徵向量</li>
      </ul>
    </div>
    <div class="ex-box"><div class="label">EXAMPLE — 2×2</div>
      <p>求 \(A = \begin{bmatrix}4&2\\3&3\end{bmatrix}\) 的特徵值與特徵向量。</p>
      <div class="formula-block">$$\det(A-\lambda I) = (4-\lambda)(3-\lambda)-6 = \lambda^2 - 7\lambda + 6 = (\lambda-1)(\lambda-6) = 0$$</div>
      <p style="color:var(--text2);font-size:14px">\(\lambda_1 = 1\)：\((A-I)\mathbf{x}=\mathbf{0}\) → \(\mathbf{x}_1 = t\begin{bmatrix}-2\\3\end{bmatrix}\)</p>
      <p style="color:var(--text2);font-size:14px">\(\lambda_2 = 6\)：\((A-6I)\mathbf{x}=\mathbf{0}\) → \(\mathbf{x}_2 = t\begin{bmatrix}1\\1\end{bmatrix}\)</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">特徵值重要性質<span class="en">Properties</span></div>
    <div class="prop-box"><div class="label">8 大性質</div>
      <ul class="prop-list">
        <li>① \(\displaystyle\sum_{i=1}^n \lambda_i = \text{tr}(A) = \sum_{i=1}^n a_{ii}\)（跡 = 特徵值之和）</li>
        <li>② \(\displaystyle\prod_{i=1}^n \lambda_i = \det(A)\)（行列式 = 特徵值之積）</li>
        <li>③ \(A\) 奇異（singular）\(\Leftrightarrow\) 存在 \(\lambda = 0\)</li>
        <li>④ \(\lambda(A^T) = \lambda(A)\)</li>
        <li>⑤ 若 \(A\mathbf{x} = \lambda\mathbf{x}\)，則 \(A^n\mathbf{x} = \lambda^n\mathbf{x}\)</li>
        <li>⑥ \(A\) 可逆時，\(A^{-1}\) 的特徵值為 \(\frac{1}{\lambda}\)</li>
        <li>⑦ \((A + cI)\) 的特徵值為 \(\lambda + c\)</li>
        <li>⑧ \(A\) 為對稱矩陣 → 特徵值皆為實數</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title">互動工具：2×2 特徵值計算器</div>
    <div class="interactive-box"><h4>輸入 2×2 矩陣，求特徵值與特徵向量</h4>
      <div class="mat-input" id="eig2-in" style="grid-template-columns:1fr 1fr">
        <input value="4" oninput="calcEig2()"><input value="2" oninput="calcEig2()">
        <input value="3" oninput="calcEig2()"><input value="3" oninput="calcEig2()">
      </div>
      <div id="eig2-out" class="result-box"></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">工程應用：三層樓建築模態分析<span class="en">3-Story Building Modal Analysis</span></div>
    <div class="def-box"><div class="label">MODEL</div>
      <p>將三層樓建築簡化為三自由度質量-彈簧系統：每層樓質量 \(m\)，層間剛度 \(k\)。</p>
      <div class="formula-block">$$M\ddot{\mathbf{x}} + K\mathbf{x} = \mathbf{0} \quad\Rightarrow\quad K\boldsymbol{\phi} = \omega^2 M\boldsymbol{\phi}$$</div>
      <p>令 \(M = mI\)，則 \(\frac{1}{m}K\boldsymbol{\phi} = \omega^2\boldsymbol{\phi}\)，這就是<strong>特徵值問題</strong>！</p>
      <p style="margin-top:6px">特徵值 \(\lambda = \omega^2\) → <strong>模態頻率</strong>（振動快慢）<br>
      特徵向量 \(\boldsymbol{\phi}\) → <strong>模態振型</strong>（每層樓如何搖擺）</p>
    </div>
    <div class="interactive-box">
      <h4>三種模態振型動畫 — 拖曳滑桿調整質量與剛度</h4>
      <div style="display:flex;gap:20px;margin-bottom:10px;flex-wrap:wrap">
        <label style="color:var(--text2);font-size:13px">質量 m = <span id="bldg-m-val">1.0</span>
          <input type="range" id="bldg-m" min="0.5" max="3" step="0.1" value="1" oninput="bldgUpdate()" style="width:100px;vertical-align:middle">
        </label>
        <label style="color:var(--text2);font-size:13px">剛度 k = <span id="bldg-k-val">1.0</span>
          <input type="range" id="bldg-k" min="0.5" max="5" step="0.1" value="1" oninput="bldgUpdate()" style="width:100px;vertical-align:middle">
        </label>
      </div>
      <canvas id="bldg-canvas" class="anim-canvas" height="420" style="background:#1b1b2f"></canvas>
      <div id="bldg-info" class="result-box" style="margin-top:10px;font-size:13px;background:rgba(27,27,47,0.6);border:1px solid rgba(180,142,173,0.2)"></div>
    </div>
  </div>
</div>

<!-- ===== §8.3 對稱矩陣 ===== -->
<div class="section" id="sec-83">
  <div class="section-tag">10</div>
  <div class="section-title">對稱矩陣</div>
  <div class="section-sub">Symmetric Matrices, Orthogonal Diagonalization</div>

  <div class="card">
    <div class="card-title">對稱矩陣性質<span class="en">Properties</span></div>
    <div class="thm-box"><div class="label">THEOREM</div>
      <ul class="prop-list">
        <li>① 對稱矩陣（\(A^T = A\)）的特徵值皆為<strong>實數</strong></li>
        <li>② 對應不同特徵值的特徵向量彼此<strong>正交</strong>（orthogonal）</li>
        <li>③ 對稱矩陣一定可以正交對角化</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title">正交對角化<span class="en">Orthogonal Diagonalization</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>若存在正交矩陣 \(P\)（即 \(P^T P = I\)）使得：</p>
      <div class="formula-block">$$P^T A P = D = \begin{bmatrix}\lambda_1 & & \\ & \lambda_2 & \\ & & \ddots\end{bmatrix}$$</div>
      <p>則稱 \(A\) 可正交對角化。\(P\) 的行即為正規化（normalized）後的特徵向量。</p>
    </div>
    <div class="note-box"><div class="label">Gram-Schmidt 正交化</div>
      <p>若同一特徵值對應多個特徵向量，需先以 Gram-Schmidt 程序將它們正交化，再正規化。</p>
      <div class="formula-block">$$\mathbf{u}_2 = \mathbf{v}_2 - \frac{\mathbf{v}_2 \cdot \mathbf{u}_1}{\mathbf{u}_1 \cdot \mathbf{u}_1}\mathbf{u}_1$$</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">動畫展示 <span class="en">Animation</span></div>
    <div style="text-align:center">
      <canvas id="cv-symm" width="760" height="360" style="background:#1b1b2f;border-radius:10px;max-width:100%"></canvas>
      <div style="font-size:11px;color:var(--text3);margin-top:6px">對稱矩陣的特徵向量正交性：特徵向量只變長，其他向量會旋轉</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">正交對角化步驟</div>
    <div class="note-box"><div class="label">PROCEDURE</div>
      <ul class="prop-list">
        <li>Step 1：求 \(A\) 的特徵值 \(\lambda_1, \lambda_2, \ldots\)</li>
        <li>Step 2：求每個 \(\lambda\) 的特徵向量</li>
        <li>Step 3：同一特徵值的特徵向量以 Gram-Schmidt 正交化</li>
        <li>Step 4：將所有特徵向量正規化（長度化為 1）</li>
        <li>Step 5：排成正交矩陣 \(P = [\mathbf{p}_1 \; \mathbf{p}_2 \; \cdots \; \mathbf{p}_n]\)</li>
      </ul>
    </div>
    <div class="ex-box"><div class="label">EXAMPLE</div>
      <p>正交對角化 \(A = \begin{bmatrix}2&1\\1&2\end{bmatrix}\)</p>
      <p style="color:var(--text2);font-size:14px">特徵值：\(\lambda_1=3,\;\lambda_2=1\)，特徵向量：\(\mathbf{x}_1=\begin{bmatrix}1\\1\end{bmatrix},\;\mathbf{x}_2=\begin{bmatrix}-1\\1\end{bmatrix}\)</p>
      <p style="color:var(--text2);font-size:14px">正規化：\(P=\begin{bmatrix}1/\sqrt{2}&-1/\sqrt{2}\\1/\sqrt{2}&1/\sqrt{2}\end{bmatrix}\)，驗證 \(P^TAP=\begin{bmatrix}3&0\\0&1\end{bmatrix}\)</p>
    </div>
  </div>
</div>

<!-- ===== 矩陣對角化 ===== -->
<div class="section" id="sec-diag">
  <div class="section-tag">09</div>
  <div class="section-title">矩陣對角化</div>
  <div class="section-sub">Diagonalization</div>

  <div class="card">
    <div class="card-title">定義<span class="en">Definition</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>若存在可逆矩陣 \(P\) 使得：</p>
      <div class="formula-block">$$P^{-1}AP = D = \text{diag}(\lambda_1, \lambda_2, \ldots, \lambda_n)$$</div>
      <p>則稱 \(A\) 可對角化。\(P\) 的行為 \(A\) 的特徵向量，\(D\) 的對角線元素為對應的特徵值。</p>
    </div>
    <div class="thm-box"><div class="label">THEOREM — 可對角化條件</div>
      <p>\(n \times n\) 矩陣 \(A\) 可對角化 \(\Leftrightarrow\) \(A\) 有 \(n\) 個線性獨立的特徵向量。</p>
      <p style="color:var(--text2);font-size:13px;margin-top:6px">充分條件：若 \(A\) 有 \(n\) 個相異特徵值，則一定可對角化。</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">動畫展示 <span class="en">Animation</span></div>
    <div style="text-align:center">
      <canvas id="cv-diag" width="760" height="360" style="background:#1b1b2f;border-radius:10px;max-width:100%"></canvas>
      <div style="font-size:11px;color:var(--text3);margin-top:6px">對角化視覺化：原始座標 vs 特徵向量座標，對角矩陣的簡潔作用</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">對角化步驟</div>
    <div class="note-box"><div class="label">PROCEDURE</div>
      <ul class="prop-list">
        <li>Step 1：解特徵方程式 \(\det(A - \lambda I) = 0\)，求出 \(\lambda_1, \ldots, \lambda_n\)</li>
        <li>Step 2：對每個 \(\lambda_i\)，解 \((A - \lambda_i I)\mathbf{x} = \mathbf{0}\)，得特徵向量 \(\mathbf{p}_i\)</li>
        <li>Step 3：組合 \(P = [\mathbf{p}_1 \; \mathbf{p}_2 \; \cdots \; \mathbf{p}_n]\)</li>
        <li>Step 4：\(D = P^{-1}AP\)（或直接寫出 \(D = \text{diag}(\lambda_1, \ldots, \lambda_n)\)）</li>
      </ul>
    </div>
    <div class="ex-box"><div class="label">EXAMPLE</div>
      <p>對角化 \(A = \begin{bmatrix}1&4\\1&1\end{bmatrix}\)</p>
      <p style="color:var(--text2);font-size:14px">\(\det(A-\lambda I) = (1-\lambda)^2 - 4 = \lambda^2-2\lambda-3=(\lambda-3)(\lambda+1)=0\)</p>
      <p style="color:var(--text2);font-size:14px">\(\lambda_1=3\)：\(\mathbf{p}_1=\begin{bmatrix}2\\1\end{bmatrix}\)，\(\lambda_2=-1\)：\(\mathbf{p}_2=\begin{bmatrix}-2\\1\end{bmatrix}\)</p>
      <div class="formula-block">$$P=\begin{bmatrix}2&-2\\1&1\end{bmatrix},\quad P^{-1}AP=\begin{bmatrix}3&0\\0&-1\end{bmatrix}$$</div>
    </div>
    <div class="note-box"><div class="label">應用：矩陣冪次</div>
      <p>若 \(A = PDP^{-1}\)，則 \(A^k = PD^kP^{-1}\)，其中 \(D^k = \text{diag}(\lambda_1^k, \ldots, \lambda_n^k)\)。</p>
    </div>
  </div>
</div>

<!-- ===== 二次式（在對稱矩陣之後） ===== -->
<div class="section" id="sec-qf">
  <div class="section-tag">11</div>
  <div class="section-title">二次式</div>
  <div class="section-sub">Quadratic Forms</div>

  <div class="card">
    <div class="card-title">定義<span class="en">Definition</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>二次式定義為：</p>
      <div class="formula-block">$$Q = \mathbf{x}^T A \mathbf{x}$$</div>
      <p>其中 \(A\) 為對稱矩陣。例如 \(Q = 2x_1^2 + 3x_2^2 + 4x_1x_2\) 對應 \(A = \begin{bmatrix}2&2\\2&3\end{bmatrix}\)。</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">正定性分類<span class="en">Definiteness</span></div>
    <div class="thm-box"><div class="label">THEOREM — 依特徵值判斷</div>
      <ul class="prop-list">
        <li><strong style="color:var(--green)">正定 Positive Definite：</strong>所有 \(\lambda_i > 0\)（\(Q > 0\) 對所有 \(\mathbf{x} \neq \mathbf{0}\)）</li>
        <li><strong style="color:var(--blue)">正半定 Positive Semi-definite：</strong>所有 \(\lambda_i \geq 0\)</li>
        <li><strong style="color:var(--red)">負定 Negative Definite：</strong>所有 \(\lambda_i < 0\)</li>
        <li><strong style="color:var(--purple)">負半定 Negative Semi-definite：</strong>所有 \(\lambda_i \leq 0\)</li>
        <li><strong style="color:var(--gold)">不定 Indefinite：</strong>\(\lambda_i\) 有正有負</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title">主軸定理<span class="en">Principal Axis Theorem</span></div>
    <div class="thm-box"><div class="label">THEOREM</div>
      <p>透過正交變換 \(\mathbf{x} = P\mathbf{y}\)（\(P\) 為正交矩陣），可將二次式化為標準式：</p>
      <div class="formula-block">$$Q = \mathbf{x}^T A \mathbf{x} = \mathbf{y}^T D \mathbf{y} = \lambda_1 y_1^2 + \lambda_2 y_2^2 + \cdots + \lambda_n y_n^2$$</div>
    </div>
    <div class="ex-box"><div class="label">EXAMPLE</div>
      <p>將 \(Q = 5x_1^2 + 8x_1x_2 + 5x_2^2\) 化為標準式。</p>
      <p style="color:var(--text2);font-size:14px">\(A=\begin{bmatrix}5&4\\4&5\end{bmatrix}\)，特徵值 \(\lambda_1=9,\;\lambda_2=1\)</p>
      <p style="color:var(--text2);font-size:14px">正交變換後：\(Q = 9y_1^2 + y_2^2\)（正定）</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">動畫展示 <span class="en">Animation</span></div>
    <div style="text-align:center">
      <canvas id="cv-qf" width="760" height="360" style="background:#1b1b2f;border-radius:10px;max-width:100%"></canvas>
      <div style="font-size:11px;color:var(--text3);margin-top:6px">二次式的等高線：原始座標的傾斜橢圓變為主軸對齐的橢圓</div>
    </div>
  </div>
</div>

<!-- ===== 線性轉換 ===== -->
<div class="section" id="sec-lt">
  <div class="section-tag">07</div>
  <div class="section-title">線性轉換</div>
  <div class="section-sub">Linear Transformation</div>

  <div class="card">
    <div class="card-title">定義<span class="en">Definition</span></div>
    <div class="def-box"><div class="label">DEFINITION</div>
      <p>函數 \(T: V \to W\) 為線性轉換，若對所有 \(\mathbf{u}, \mathbf{v} \in V\) 及純量 \(\alpha, \beta\)：</p>
      <div class="formula-block">$$T(\alpha\mathbf{u} + \beta\mathbf{v}) = \alpha\,T(\mathbf{u}) + \beta\,T(\mathbf{v})$$</div>
    </div>
    <div class="ex-box"><div class="label">EXAMPLE</div>
      <p>\(T: \mathbb{R}^2 \to \mathbb{R}^2\) 定義為 \(T\begin{bmatrix}x\\y\end{bmatrix} = \begin{bmatrix}2x+y\\x-y\end{bmatrix}\)，對應矩陣 \(A=\begin{bmatrix}2&1\\1&-1\end{bmatrix}\)。</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">線性轉換動畫</div>
    <div class="interactive-box">
      <h4>輸入 2×2 矩陣或選擇預設轉換</h4>
      <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:12px">
        <div><label style="display:block;color:var(--text2);font-size:12px;margin-bottom:4px">選擇預設：</label>
          <select id="lt-preset" onchange="ltSetPreset()" style="background:rgba(255,255,255,0.1);color:var(--text);border:1px solid var(--border2);padding:6px 12px;border-radius:4px;font-family:inherit">
            <option value="">自定義</option>
            <option value="rot45">旋轉 45°</option>
            <option value="scale">縮放 2x, 0.5y</option>
            <option value="shear">剪切</option>
            <option value="reflect">反射</option>
          </select>
        </div>
        <div style="display:flex;gap:8px">
          <div><label style="display:block;color:var(--text2);font-size:11px">a</label>
            <input id="lt-a" type="number" value="1" step="0.1" style="width:50px;background:rgba(255,255,255,0.1);color:var(--text);border:1px solid var(--border2);padding:4px;border-radius:4px"></div>
          <div><label style="display:block;color:var(--text2);font-size:11px">b</label>
            <input id="lt-b" type="number" value="0" step="0.1" style="width:50px;background:rgba(255,255,255,0.1);color:var(--text);border:1px solid var(--border2);padding:4px;border-radius:4px"></div>
          <div><label style="display:block;color:var(--text2);font-size:11px">c</label>
            <input id="lt-c" type="number" value="0" step="0.1" style="width:50px;background:rgba(255,255,255,0.1);color:var(--text);border:1px solid var(--border2);padding:4px;border-radius:4px"></div>
          <div><label style="display:block;color:var(--text2);font-size:11px">d</label>
            <input id="lt-d" type="number" value="1" step="0.1" style="width:50px;background:rgba(255,255,255,0.1);color:var(--text);border:1px solid var(--border2);padding:4px;border-radius:4px"></div>
        </div>
      </div>
      <canvas id="lt-canvas" class="anim-canvas" height="450" style="background:#1b1b2f"></canvas>
      <div class="anim-controls">
        <button class="btn btn-gold btn-sm" onclick="ltPlayAnimation()">播放轉換</button>
        <button class="btn btn-gold btn-sm" onclick="ltReset()">重置</button>
      </div>
      <div id="lt-info" class="result-box" style="margin-top:10px;font-size:13px;background:rgba(27,27,47,0.6);border:1px solid rgba(131,193,103,0.2)"></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title">核空間與值域<span class="en">Kernel and Range</span></div>
    <div class="def-box"><div class="label">DEFINITIONS</div>
      <ul class="prop-list">
        <li><strong style="color:var(--teal)">核空間 Kernel：</strong>\(\text{Ker}(T) = \{\mathbf{v} \in V \;|\; T(\mathbf{v}) = \mathbf{0}\}\)（即零空間 \(N(A)\)）</li>
        <li><strong style="color:var(--purple)">值域 Range：</strong>\(\text{Range}(T) = \{T(\mathbf{v}) \;|\; \mathbf{v} \in V\}\)（即行空間）</li>
      </ul>
    </div>
    <div class="thm-box"><div class="label">THEOREM — 維度定理</div>
      <div class="formula-block">$$\dim(\text{Ker}(T)) + \dim(\text{Range}(T)) = \dim(V)$$</div>
      <p>等同於 Rank-Nullity 定理。</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title">線性轉換判斷<span class="en">Verification</span></div>
    <div class="note-box"><div class="label">快速判斷</div>
      <ul class="prop-list">
        <li>① 必要條件：\(T(\mathbf{0}) = \mathbf{0}\)</li>
        <li>② 檢驗齊次性：\(T(c\mathbf{v}) = cT(\mathbf{v})\)</li>
        <li>③ 檢驗可加性：\(T(\mathbf{u}+\mathbf{v}) = T(\mathbf{u})+T(\mathbf{v})\)</li>
      </ul>
    </div>
  </div>
</div>

<div class="footer">工程數學二 線性代數互動教學 — 依據課程講義編製</div>
</div></div>

<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
<script>
// ===== ORIGINAL FUNCTIONS =====
function stopNewAnims(){
  if(animMatvecState.animId){cancelAnimationFrame(animMatvecState.animId);animMatvecState.animId=null;}
  if(animMatmulState.animId){cancelAnimationFrame(animMatmulState.animId);animMatmulState.animId=null;}
  if(animInverseState.animId){cancelAnimationFrame(animInverseState.animId);animInverseState.animId=null;}
  if(animSymmState.animId){cancelAnimationFrame(animSymmState.animId);animSymmState.animId=null;}
  if(animDiagState.animId){cancelAnimationFrame(animDiagState.animId);animDiagState.animId=null;}
  if(animQfState.animId){cancelAnimationFrame(animQfState.animId);animQfState.animId=null;}
  if(typeof bldgAnimState!=='undefined'&&bldgAnimState.animId){cancelAnimationFrame(bldgAnimState.animId);bldgAnimState.animId=null;}
  if(typeof detDragState!=='undefined'&&detDragState.animId){cancelAnimationFrame(detDragState.animId);detDragState.animId=null;detDragState.autoAnim=false;}
  if(typeof spanAutoAnimState!=='undefined'&&spanAutoAnimState.animId){cancelAnimationFrame(spanAutoAnimState.animId);spanAutoAnimState.animId=null;spanAutoAnimState.active=false;}
  if(typeof ltAnimState!=='undefined'&&ltAnimState.animId){cancelAnimationFrame(ltAnimState.animId);ltAnimState.animId=null;ltAnimState.playing=false;}
  if(typeof eigAnimState!=='undefined'&&eigAnimState.animId){cancelAnimationFrame(eigAnimState.animId);eigAnimState.animId=null;eigAnimState.playing=false;}
  if(typeof gaussAnimState!=='undefined'){gaussAnimState.playing=false;}
}
function initCanvasesInSection(sec){
  if(!sec)return;
  stopNewAnims();
  setTimeout(()=>{
    const canvases=sec.querySelectorAll('canvas.anim-canvas');
    canvases.forEach(c=>{
      const parent=c.parentElement;
      if(parent){
        const w=parent.clientWidth-36;
        if(w>0){c.style.width=w+'px';c.width=w;}
      }
    });
    if(sec.id==='sec-lt'&&document.getElementById('lt-canvas')){ltPlayAnimation();}
    if(sec.id==='sec-77'&&document.getElementById('det-canvas')){detDragState.autoAnim=true;detDragState.t=0;detAutoAnim();}
    if(sec.id==='sec-74'&&document.getElementById('span-canvas')){spanAutoAnimState.active=true;spanAutoAnimState.t=0;spanAutoAnim();}
    if(sec.id==='sec-73'&&document.getElementById('gauss-anim-canvas')){gaussAnimReset();setTimeout(gaussAnimAuto,300);}
    if(sec.id==='sec-81'&&document.getElementById('eig-canvas')){eigAnimReset();setTimeout(eigAnimTransform,200);}
    if(sec.id==='sec-81'&&document.getElementById('bldg-canvas')){bldgUpdate();}
    if(sec.id==='sec-71'&&document.getElementById('cv-matvec')){animMatvecState.t=0;animMatvecDraw(0);}
    if(sec.id==='sec-72'&&document.getElementById('cv-matmul')){animMatmulState.t=0;animMatmulDraw();}
    if(sec.id==='sec-78'&&document.getElementById('cv-inverse')){animInverseState.t=0;animInverseDraw(0);}
    if(sec.id==='sec-83'&&document.getElementById('cv-symm')){animSymmState.t=0;animSymmDraw(0);}
    if(sec.id==='sec-diag'&&document.getElementById('cv-diag')){animDiagState.t=0;animDiagDraw(0);}
    if(sec.id==='sec-qf'&&document.getElementById('cv-qf')){animQfState.t=0;animQfDraw(0);}
  },100);
}
function go(id){
  document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
  document.querySelectorAll('.nav-item').forEach(n=>n.classList.remove('active'));
  const sec=document.getElementById(id);
  if(sec){sec.classList.add('active');window.scrollTo(0,0);}
  document.querySelectorAll('.nav-item').forEach(n=>{if(n.getAttribute('onclick')&&n.getAttribute('onclick').includes(id))n.classList.add('active');});
  document.querySelector('.sidebar').classList.remove('open');
  setTimeout(()=>{if(sec)renderMathInElement(sec,{delimiters:[{left:'$$',right:'$$',display:true},{left:'\\(',right:'\\)',display:false}],throwOnError:false});},50);
  initCanvasesInSection(sec);
}
function calcTranspose(){
  const inp=[...document.querySelectorAll('#trans-in input')].map(i=>parseFloat(i.value)||0);
  const t=[[inp[0],inp[3]],[inp[1],inp[4]],[inp[2],inp[5]]];
  document.getElementById('trans-out').innerHTML=t.map(r=>'[ '+r.join('  ')+' ]').join('<br>');
}
function calcMul(){
  const a=[...document.querySelectorAll('#mul-a input')].map(i=>parseFloat(i.value)||0);
  const b=[...document.querySelectorAll('#mul-b input')].map(i=>parseFloat(i.value)||0);
  const A=[[a[0],a[1]],[a[2],a[3]]],B=[[b[0],b[1]],[b[2],b[3]]];
  const mul=(X,Y)=>[[X[0][0]*Y[0][0]+X[0][1]*Y[1][0],X[0][0]*Y[0][1]+X[0][1]*Y[1][1]],[X[1][0]*Y[0][0]+X[1][1]*Y[1][0],X[1][0]*Y[0][1]+X[1][1]*Y[1][1]]];
  const fmt=M=>M.map(r=>'[ '+r.join('  ')+' ]').join('<br>');
  const AB=mul(A,B),BA=mul(B,A);
  document.getElementById('mul-out').innerHTML=fmt(AB);
  document.getElementById('mul-out-ba').innerHTML=fmt(BA);
  function stepHtml(X,Y,label){
    const n=['₁₁','₁₂','₂₁','₂₂'];
    const pos=[[0,0],[0,1],[1,0],[1,1]];
    let h='<div style="font-size:12px;font-weight:700;color:var(--teal);margin-bottom:4px">'+label+' 計算步驟：</div>';
    pos.forEach(([i,j],idx)=>{
      const c1=X[i][0],c2=X[i][1],d1=Y[0][j],d2=Y[1][j];
      const res=c1*d1+c2*d2;
      h+='<span style="color:var(--gold)">c'+n[idx]+'</span> = ';
      h+='('+c1+')('+d1+') + ('+c2+')('+d2+') = ';
      h+='<span style="color:var(--text)">'+(c1*d1)+'</span> + <span style="color:var(--text)">'+(c2*d2)+'</span> = ';
      h+='<strong style="color:var(--gold)">'+res+'</strong><br>';
    });
    return h;
  }
  document.getElementById('mul-steps').innerHTML=stepHtml(A,B,'AB');
  document.getElementById('mul-steps-ba').innerHTML=stepHtml(B,A,'BA');
  const eq=AB[0][0]===BA[0][0]&&AB[0][1]===BA[0][1]&&AB[1][0]===BA[1][0]&&AB[1][1]===BA[1][1];
  const cmp=document.getElementById('mul-compare');
  if(eq){cmp.style.background='rgba(59,165,93,0.15)';cmp.innerHTML='<span style="color:var(--green)">✓ 此例中 AB = BA（特殊情況）</span>';}
  else{cmp.style.background='rgba(224,85,85,0.15)';cmp.innerHTML='<span style="color:var(--red)">✗ AB ≠ BA — 矩陣乘法不可交換</span>';}
}
function calcDet2(){
  const v=[...document.querySelectorAll('#det2-in input')].map(i=>parseFloat(i.value)||0);
  document.getElementById('det2-out').innerHTML='det = ('+v[0]+')('+v[3]+') - ('+v[1]+')('+v[2]+') = <strong style="color:var(--gold)">'+(v[0]*v[3]-v[1]*v[2])+'</strong>';
}
function calcDet3(){
  const v=[...document.querySelectorAll('#det3-in input')].map(i=>parseFloat(i.value)||0);
  const[a,b,c,d,e,f,g,h,k]=v;
  const det=a*(e*k-f*h)-b*(d*k-f*g)+c*(d*h-e*g);
  document.getElementById('det3-out').innerHTML='沿第一列展開：<br>= '+a+'('+e+'·'+k+'-'+f+'·'+h+') - '+b+'('+d+'·'+k+'-'+f+'·'+g+') + '+c+'('+d+'·'+h+'-'+e+'·'+g+')<br>= <strong style="color:var(--gold)">'+det+'</strong>';
}
function calcInv2(){
  const v=[...document.querySelectorAll('#inv2-in input')].map(i=>parseFloat(i.value)||0);
  const det=v[0]*v[3]-v[1]*v[2];const el=document.getElementById('inv2-out');
  if(Math.abs(det)<1e-10){el.innerHTML='<span style="color:var(--red)">det=0，不可逆</span>';return;}
  const inv=[[v[3]/det,-v[1]/det],[-v[2]/det,v[0]/det]];
  el.innerHTML='det = '+det+'<br>A⁻¹ = (1/'+det+') '+inv.map(r=>'[ '+r.map(x=>Number.isInteger(x)?x:x.toFixed(4)).join(', ')+' ]').join('<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');
}
function calcEig2(){
  const v=[...document.querySelectorAll('#eig2-in input')].map(i=>parseFloat(i.value)||0);
  const[a,b,c,d]=v;const tr=a+d,det=a*d-b*c,disc=tr*tr-4*det;
  let h='tr(A)='+tr+', det(A)='+det+'<br>λ²-'+tr+'λ+'+det+'=0, Δ='+disc.toFixed(2)+'<br>';
  if(disc<-1e-10){const re=tr/2,im=Math.sqrt(-disc)/2;h+='λ='+re.toFixed(2)+'±'+im.toFixed(2)+'i';}
  else{const l1=(tr+Math.sqrt(Math.max(0,disc)))/2,l2=(tr-Math.sqrt(Math.max(0,disc)))/2;
    h+='<strong style="color:var(--gold)">λ₁='+l1.toFixed(4)+'</strong>, <strong style="color:var(--purple)">λ₂='+l2.toFixed(4)+'</strong>';
    [[l1,'λ₁'],[l2,'λ₂']].forEach(([lam,lb])=>{const m0=a-lam,m1=b;
      if(Math.abs(m1)>1e-10)h+='<br>'+lb+' 特徵向量∝ ['+(-m1).toFixed(2)+', '+m0.toFixed(2)+']ᵀ';
      else if(Math.abs(m0)>1e-10)h+='<br>'+lb+' 特徵向量∝ [0, 1]ᵀ';
      else h+='<br>'+lb+' 特徵向量∝ [1, 0]ᵀ';});}
  document.getElementById('eig2-out').innerHTML=h;
}
function runGauss(){
  const inp=[...document.querySelectorAll('#gauss-in input')].map(i=>parseFloat(i.value)||0);
  let M=[[inp[0],inp[1],inp[2],inp[3]],[inp[4],inp[5],inp[6],inp[7]],[inp[8],inp[9],inp[10],inp[11]]];
  const fmt=m=>m.map(r=>'[ '+r.map(x=>{let s=Number.isInteger(x)?x.toString():x.toFixed(3);return s.padStart(8)}).join(' ')+' ]').join('\n');
  let log='原始增廣矩陣：\n'+fmt(M)+'\n';
  for(let col=0;col<3;col++){
    let pivot=-1;for(let r=col;r<3;r++){if(Math.abs(M[r][col])>1e-10){pivot=r;break;}}
    if(pivot<0)continue;
    if(pivot!==col){[M[col],M[pivot]]=[M[pivot],M[col]];log+='\nR'+(col+1)+'↔R'+(pivot+1)+'：\n'+fmt(M)+'\n';}
    for(let r=col+1;r<3;r++){
      if(Math.abs(M[r][col])<1e-10)continue;
      const f=-M[r][col]/M[col][col];
      for(let c=0;c<4;c++)M[r][c]+=f*M[col][c];M[r][col]=0;
      log+='\nR'+(r+1)+' + ('+f.toFixed(3)+')R'+(col+1)+'：\n'+fmt(M)+'\n';
    }
  }
  log+='\n列梯式 (REF) 完成。\n';
  let rankA=0,rankAb=0;
  for(let r=0;r<3;r++){let nz=false;for(let c=0;c<3;c++)if(Math.abs(M[r][c])>1e-10)nz=true;if(nz)rankA++;let nz2=false;for(let c=0;c<4;c++)if(Math.abs(M[r][c])>1e-10)nz2=true;if(nz2)rankAb++;}
  log+='\nrank(A)='+rankA+', rank([A|b])='+rankAb+', n=3\n';
  if(rankA!==rankAb)log+='→ 無解（矛盾）';
  else if(rankA<3)log+='→ 無窮多解（自由變數 '+(3-rankA)+' 個）';
  else{
    let x=[0,0,0];
    for(let r=2;r>=0;r--){let s=M[r][3];for(let c=r+1;c<3;c++)s-=M[r][c]*x[c];x[r]=s/M[r][r];}
    log+='→ 唯一解：x₁='+x[0].toFixed(4)+', x₂='+x[1].toFixed(4)+', x₃='+x[2].toFixed(4);
  }
  document.getElementById('gauss-steps').textContent=log;
}

// ===== SHARED HELPER FUNCTIONS =====
function drawArrow(ctx,x1,y1,x2,y2,color,lineW,headSize){
  const dx=x2-x1,dy=y2-y1,len=Math.hypot(dx,dy);
  if(len<1)return;
  const ux=dx/len,uy=dy/len;
  ctx.strokeStyle=color;ctx.lineWidth=lineW;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2-ux*headSize*0.5,y2-uy*headSize*0.5);ctx.stroke();
  // arrowhead (filled triangle)
  ctx.fillStyle=color;ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2-ux*headSize-uy*headSize*0.4,y2-uy*headSize+ux*headSize*0.4);
  ctx.lineTo(x2-ux*headSize+uy*headSize*0.4,y2-uy*headSize-ux*headSize*0.4);
  ctx.closePath();ctx.fill();
}

// ===== ANIMATION FUNCTIONS =====

// 1. Linear Transformation Animation
let ltAnimState={t:0,playing:false,animId:null};
function ltSetPreset(){
  const val=document.getElementById('lt-preset').value;
  const presets={
    rot45:{a:Math.cos(Math.PI/4),b:-Math.sin(Math.PI/4),c:Math.sin(Math.PI/4),d:Math.cos(Math.PI/4)},
    scale:{a:2,b:0,c:0,d:0.5},
    shear:{a:1,b:0.5,c:0,d:1},
    reflect:{a:-1,b:0,c:0,d:1}
  };
  if(presets[val]){
    const p=presets[val];
    document.getElementById('lt-a').value=p.a.toFixed(2);
    document.getElementById('lt-b').value=p.b.toFixed(2);
    document.getElementById('lt-c').value=p.c.toFixed(2);
    document.getElementById('lt-d').value=p.d.toFixed(2);
  }
  ltReset();
}
function ltPlayAnimation(){
  ltAnimState.t=0;
  ltAnimState.playing=true;
  ltAnimateDraw();
}
function ltReset(){
  ltAnimState.t=0;
  ltAnimState.playing=false;
  if(ltAnimState.animId)cancelAnimationFrame(ltAnimState.animId);
  ltDraw(0);
}
function ltAnimateDraw(){
  if(!ltAnimState.playing)return;
  ltAnimState.t+=0.012;
  if(ltAnimState.t>2){ ltAnimState.t=0; } // loop: 0→1 forward, 1→2 pause then restart
  ltDraw(Math.min(ltAnimState.t,1));
  ltAnimState.animId=requestAnimationFrame(ltAnimateDraw);
}
function ltDraw(t){
  const c=document.getElementById('lt-canvas');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||c.parentElement.clientWidth||600;
  const h=450;
  c.width=w*2;c.height=h*2;c.style.height=h+'px';
  ctx.scale(2,2);
  const cx=w/2,cy=h/2,scale=55;
  const a=parseFloat(document.getElementById('lt-a').value)||0;
  const b=parseFloat(document.getElementById('lt-b').value)||0;
  const dd=parseFloat(document.getElementById('lt-c').value)||0;
  const ee=parseFloat(document.getElementById('lt-d').value)||0;
  function easeInOut(x){return x<0.5?2*x*x:1-Math.pow(-2*x+2,2)/2;}
  const et=easeInOut(t);
  const A=[[1*(1-et)+a*et,0*(1-et)+b*et],[0*(1-et)+dd*et,1*(1-et)+ee*et]];
  const det=A[0][0]*A[1][1]-A[0][1]*A[1][0];

  // Background
  ctx.fillStyle='#1b1b2f';ctx.fillRect(0,0,w,h);

  // Standard grid (subtle)
  ctx.strokeStyle='#2a2a4a';ctx.lineWidth=0.5;
  for(let i=-4;i<=4;i++){
    ctx.beginPath();ctx.moveTo(cx+i*scale,0);ctx.lineTo(cx+i*scale,h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,cy+i*scale);ctx.lineTo(w,cy+i*scale);ctx.stroke();
  }

  // Transformed grid (parallelogram cells)
  for(let i=-2;i<2;i++){
    for(let j=-2;j<2;j++){
      const p1=[i,j],p2=[i+1,j],p3=[i+1,j+1],p4=[i,j+1];
      const ap1=[A[0][0]*p1[0]+A[0][1]*p1[1],A[1][0]*p1[0]+A[1][1]*p1[1]];
      const ap2=[A[0][0]*p2[0]+A[0][1]*p2[1],A[1][0]*p2[0]+A[1][1]*p2[1]];
      const ap3=[A[0][0]*p3[0]+A[0][1]*p3[1],A[1][0]*p3[0]+A[1][1]*p3[1]];
      const ap4=[A[0][0]*p4[0]+A[0][1]*p4[1],A[1][0]*p4[0]+A[1][1]*p4[1]];
      const x1=cx+ap1[0]*scale,y1=cy-ap1[1]*scale;
      const x2=cx+ap2[0]*scale,y2=cy-ap2[1]*scale;
      const x3=cx+ap3[0]*scale,y3=cy-ap3[1]*scale;
      const x4=cx+ap4[0]*scale,y4=cy-ap4[1]*scale;
      // Fill cell with blend of green and red
      const blend=Math.abs(i)/(2)+Math.abs(j)/(2);
      const gAlpha=Math.abs(A[0][0])>0.1?0.08:0.04;
      ctx.fillStyle=det>0?'rgba(131,193,103,'+gAlpha+')':'rgba(252,98,85,'+gAlpha+')';
      ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.lineTo(x3,y3);ctx.lineTo(x4,y4);ctx.closePath();ctx.fill();
      // Cell border
      ctx.strokeStyle='#4a4a7a';ctx.lineWidth=0.5;
      ctx.stroke();
    }
  }

  // Axes with labels
  ctx.strokeStyle='#4a4a7a';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(0,cy);ctx.lineTo(w,cy);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx,0);ctx.lineTo(cx,h);ctx.stroke();

  // Axis labels
  ctx.fillStyle='rgba(200,192,176,0.5)';ctx.font='11px JetBrains Mono';ctx.textAlign='center';
  for(let i=-4;i<=4;i++){
    if(i===0)continue;
    ctx.fillText(i,cx+i*scale,cy+14);
    ctx.fillText(i,cx-14,cy-i*scale+4);
  }
  ctx.fillStyle='rgba(200,192,176,0.6)';ctx.font='bold 11px JetBrains Mono';
  ctx.fillText('O',cx-10,cy+14);

  // Basis vectors e1 and e2 with glow
  const e1=[A[0][0],A[1][0]],e2=[A[0][1],A[1][1]];

  // e1 (green)
  drawArrow(ctx,cx,cy,cx+e1[0]*scale,cy-e1[1]*scale,'#83c167',3.5,13);
  ctx.shadowColor='#83c167';ctx.shadowBlur=12;
  ctx.fillStyle='#83c167';ctx.beginPath();ctx.arc(cx+e1[0]*scale,cy-e1[1]*scale,5,0,Math.PI*2);ctx.fill();
  ctx.shadowBlur=0;

  // e2 (red)
  drawArrow(ctx,cx,cy,cx+e2[0]*scale,cy-e2[1]*scale,'#fc6255',3.5,13);
  ctx.shadowColor='#fc6255';ctx.shadowBlur=12;
  ctx.fillStyle='#fc6255';ctx.beginPath();ctx.arc(cx+e2[0]*scale,cy-e2[1]*scale,5,0,Math.PI*2);ctx.fill();
  ctx.shadowBlur=0;

  // Labels
  ctx.fillStyle='#83c167';ctx.font='bold 14px "Noto Sans TC"';ctx.textAlign='left';
  ctx.fillText('e₁',cx+e1[0]*scale+10,cy-e1[1]*scale-8);
  ctx.fillStyle='#fc6255';
  ctx.fillText('e₂',cx+e2[0]*scale+10,cy-e2[1]*scale-8);

  // Unit square corners as dots
  ctx.fillStyle='rgba(255,255,255,0.3)';
  [[0,0],[1,0],[1,1],[0,1]].forEach(([i,j])=>{
    const p=[i,j];
    const ap=[A[0][0]*p[0]+A[0][1]*p[1],A[1][0]*p[0]+A[1][1]*p[1]];
    const x=cx+ap[0]*scale,y=cy-ap[1]*scale;
    ctx.beginPath();ctx.arc(x,y,3,0,Math.PI*2);ctx.fill();
  });

  // Update info
  const info=document.getElementById('lt-info');
  if(info){
    info.innerHTML='矩陣 A = [['+a.toFixed(2)+', '+b.toFixed(2)+'], ['+dd.toFixed(2)+', '+ee.toFixed(2)+']]\n'
      +'det(A) = '+det.toFixed(4);
  }
}

// 2. Determinant Area Animation
let detDragState={dragging:false,dragX:0,dragY:0,v1:[2,0],v2:[0,1.5],autoAnim:true,animId:null,t:0};
document.addEventListener('mousedown',e=>{
  const c=document.getElementById('det-canvas');
  if(!c||e.target!==c)return;
  detDragState.autoAnim=false; // stop auto when user interacts
  if(detDragState.animId){cancelAnimationFrame(detDragState.animId);detDragState.animId=null;}
  const rect=c.getBoundingClientRect();
  const x=(e.clientX-rect.left)/rect.width*c.clientWidth;
  const y=(e.clientY-rect.top)/rect.height*c.clientHeight;
  const cx=c.clientWidth/2,cy=c.clientHeight/2,scale=40;
  const d1=[cx+detDragState.v1[0]*scale,cy-detDragState.v1[1]*scale];
  const d2=[cx+detDragState.v2[0]*scale,cy-detDragState.v2[1]*scale];
  const dist1=Math.hypot(x-d1[0],y-d1[1]);
  const dist2=Math.hypot(x-d2[0],y-d2[1]);
  if(dist1<20){detDragState.dragging='v1';detDragState.dragX=x;detDragState.dragY=y;}
  else if(dist2<20){detDragState.dragging='v2';detDragState.dragX=x;detDragState.dragY=y;}
});
document.addEventListener('mousemove',e=>{
  const c=document.getElementById('det-canvas');
  if(!detDragState.dragging||!c)return;
  const rect=c.getBoundingClientRect();
  const x=(e.clientX-rect.left)/rect.width*c.clientWidth;
  const y=(e.clientY-rect.top)/rect.height*c.clientHeight;
  const cx=c.clientWidth/2,cy=c.clientHeight/2,scale=40;
  if(detDragState.dragging==='v1'){
    detDragState.v1=[(x-cx)/scale,-(y-cy)/scale];
  }else if(detDragState.dragging==='v2'){
    detDragState.v2=[(x-cx)/scale,-(y-cy)/scale];
  }
  detDrawCanvas();
});
document.addEventListener('mouseup',()=>{detDragState.dragging=false;});
function detAutoAnim(){
  if(!detDragState.autoAnim)return;
  detDragState.t+=0.008;
  // v1 rotates slowly, v2 rotates at different rate → area changes
  detDragState.v1=[2*Math.cos(detDragState.t*0.7), 2*Math.sin(detDragState.t*0.7)];
  detDragState.v2=[1.5*Math.cos(detDragState.t*0.4+1.2), 1.5*Math.sin(detDragState.t*0.4+1.2)];
  detDrawCanvas();
  detDragState.animId=requestAnimationFrame(detAutoAnim);
}
function detDrawCanvas(){
  const c=document.getElementById('det-canvas');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||c.parentElement.clientWidth||600;
  const h=450;
  c.width=w*2;c.height=h*2;c.style.height=h+'px';
  ctx.scale(2,2);
  const cx=w/2,cy=h/2,scale=55;
  const v1=detDragState.v1,v2=detDragState.v2;
  const det=v1[0]*v2[1]-v1[1]*v2[0];

  // Background
  ctx.fillStyle='#1b1b2f';ctx.fillRect(0,0,w,h);

  // Standard grid (subtle)
  ctx.strokeStyle='#2a2a4a';ctx.lineWidth=0.5;
  for(let i=-4;i<=4;i++){
    ctx.beginPath();ctx.moveTo(cx+i*scale,0);ctx.lineTo(cx+i*scale,h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,cy+i*scale);ctx.lineTo(w,cy+i*scale);ctx.stroke();
  }

  // Axes
  ctx.strokeStyle='#4a4a7a';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(0,cy);ctx.lineTo(w,cy);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx,0);ctx.lineTo(cx,h);ctx.stroke();

  // Axis labels
  ctx.fillStyle='rgba(200,192,176,0.5)';ctx.font='11px JetBrains Mono';ctx.textAlign='center';
  for(let i=-4;i<=4;i++){
    if(i===0)continue;
    ctx.fillText(i,cx+i*scale,cy+14);
    ctx.fillText(i,cx-14,cy-i*scale+4);
  }

  // Unit square (white dashed)
  ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.lineWidth=1;ctx.setLineDash([4,3]);
  ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx+scale,cy);ctx.lineTo(cx+scale,cy-scale);ctx.lineTo(cx,cy-scale);ctx.closePath();ctx.stroke();
  ctx.setLineDash([]);

  // Parallelogram formed by v1 and v2
  const p1=[cx,cy];
  const p2=[cx+v1[0]*scale,cy-v1[1]*scale];
  const p3=[cx+v2[0]*scale,cy-v2[1]*scale];
  const p4=[cx+(v1[0]+v2[0])*scale,cy-(v1[1]+v2[1])*scale];

  // Fill with gradient based on det sign
  const col=det>0?'rgba(131,193,103,0.25)':det<0?'rgba(252,98,85,0.25)':'rgba(180,142,173,0.25)';
  ctx.fillStyle=col;ctx.beginPath();ctx.moveTo(p1[0],p1[1]);ctx.lineTo(p2[0],p2[1]);ctx.lineTo(p4[0],p4[1]);ctx.lineTo(p3[0],p3[1]);ctx.closePath();ctx.fill();

  // Dashed parallelogram outline
  ctx.strokeStyle=det>0?'rgba(131,193,103,0.6)':det<0?'rgba(252,98,85,0.6)':'rgba(180,142,173,0.8)';
  ctx.lineWidth=1.5;ctx.setLineDash([5,3]);
  ctx.beginPath();ctx.moveTo(p1[0],p1[1]);ctx.lineTo(p2[0],p2[1]);ctx.lineTo(p4[0],p4[1]);ctx.lineTo(p3[0],p3[1]);ctx.closePath();ctx.stroke();
  ctx.setLineDash([]);

  // v1 vector (green) with arrow and glow
  drawArrow(ctx,cx,cy,p2[0],p2[1],'#83c167',3.5,13);
  ctx.shadowColor='#83c167';ctx.shadowBlur=15;
  ctx.fillStyle='#83c167';ctx.beginPath();ctx.arc(p2[0],p2[1],5,0,Math.PI*2);ctx.fill();
  ctx.shadowBlur=0;

  // v2 vector (red) with arrow and glow
  drawArrow(ctx,cx,cy,p3[0],p3[1],'#fc6255',3.5,13);
  ctx.shadowColor='#fc6255';ctx.shadowBlur=15;
  ctx.fillStyle='#fc6255';ctx.beginPath();ctx.arc(p3[0],p3[1],5,0,Math.PI*2);ctx.fill();
  ctx.shadowBlur=0;

  // Show area value in parallelogram center
  const area=Math.abs(det);
  const centerX=(p1[0]+p4[0])/2,centerY=(p1[1]+p4[1])/2;
  ctx.fillStyle=det===0?'rgba(180,142,173,0.8)':det>0?'rgba(131,193,103,0.8)':'rgba(252,98,85,0.8)';
  ctx.font='bold 13px JetBrains Mono';ctx.textAlign='center';
  if(area>0.3)ctx.fillText(area.toFixed(2),centerX,centerY+4);

  // Labels
  ctx.fillStyle='#83c167';ctx.font='bold 13px "Noto Sans TC"';ctx.textAlign='left';
  ctx.fillText('v₁',p2[0]+8,p2[1]-8);
  ctx.fillStyle='#fc6255';
  ctx.fillText('v₂',p3[0]+8,p3[1]-8);

  // Info panel
  const info=document.getElementById('det-info');
  if(info){
    const area=Math.abs(det);
    const detText=det>0?'(正行列式)':det<0?'(負行列式)':'(奇異矩陣)';
    const detColor=det>0?'#83c167':det<0?'#fc6255':'#b48ead';
    info.innerHTML='v₁ = ['+v1[0].toFixed(2)+', '+v1[1].toFixed(2)+'] &nbsp; v₂ = ['+v2[0].toFixed(2)+', '+v2[1].toFixed(2)+']<br>'
      +'<span style="color:'+detColor+'">det(A) = '+det.toFixed(4)+' &nbsp; 面積 = '+area.toFixed(4)+' &nbsp; '+detText+'</span>';
  }
}

// 3. Vector Space Span — 3Blue1Brown Style
var spanAutoAnimState={active:false,animId:null,t:0};
function spanAutoAnim(){
  if(!spanAutoAnimState.active)return;
  spanAutoAnimState.t+=0.006;
  const t=spanAutoAnimState.t;
  // Cycle c1 and c2 in a Lissajous pattern
  const c1=2*Math.sin(t*1.1);
  const c2=2*Math.cos(t*0.7);
  // Update sliders if they exist
  const s1=document.getElementById('span-c1');
  const s2=document.getElementById('span-c2');
  if(s1)s1.value=c1.toFixed(2);
  if(s2)s2.value=c2.toFixed(2);
  spanDrawCanvas(c1,c2);
  spanAutoAnimState.animId=requestAnimationFrame(spanAutoAnim);
}
let spanState={
  v1:[2,1], v2:[-1,1.5],
  dragging:false, dragTarget:null,
  animating:false, animId:null, animT:0,
  animC1From:0, animC2From:0, animC1To:0, animC2To:0
};
const SPAN_BG='#1b1b2f';
const SPAN_GRID='#2a2a4a';
const SPAN_AXIS='#4a4a7a';
const SPAN_V1='#83c167'; // 3b1b green
const SPAN_V2='#fc6255'; // 3b1b red
const SPAN_RESULT='#ffff00'; // yellow
const SPAN_COMP='rgba(255,255,255,0.25)';
function spanGetCanvasCoords(e,c){
  const rect=c.getBoundingClientRect();
  const scaleX=c.width/rect.width, scaleY=c.height/rect.height;
  return[(e.clientX-rect.left)*scaleX,(e.clientY-rect.top)*scaleY];
}
function spanToWorld(px,py,cx,cy,scale){return[(px-cx)/scale,-(py-cy)/scale];}
function spanToScreen(wx,wy,cx,cy,scale){return[cx+wx*scale,cy-wy*scale];}
document.addEventListener('mousedown',e=>{
  const c=document.getElementById('span-canvas');
  if(!c||e.target!==c)return;
  const[mx,my]=spanGetCanvasCoords(e,c);
  const cx=c.width/2,cy=c.height/2,scale=c.width/14;
  const[sx1,sy1]=spanToScreen(spanState.v1[0],spanState.v1[1],cx,cy,scale);
  const[sx2,sy2]=spanToScreen(spanState.v2[0],spanState.v2[1],cx,cy,scale);
  if(Math.hypot(mx-sx1,my-sy1)<18){spanState.dragging=true;spanState.dragTarget='v1';spanAutoAnimState.active=false;}
  else if(Math.hypot(mx-sx2,my-sy2)<18){spanState.dragging=true;spanState.dragTarget='v2';spanAutoAnimState.active=false;}
});
document.addEventListener('mousemove',e=>{
  if(!spanState.dragging)return;
  const c=document.getElementById('span-canvas');
  if(!c)return;
  const[mx,my]=spanGetCanvasCoords(e,c);
  const cx=c.width/2,cy=c.height/2,scale=c.width/14;
  const[wx,wy]=spanToWorld(mx,my,cx,cy,scale);
  // Snap to grid if close
  const sx=Math.abs(wx-Math.round(wx))<0.15?Math.round(wx):wx;
  const sy=Math.abs(wy-Math.round(wy))<0.15?Math.round(wy):wy;
  if(spanState.dragTarget==='v1')spanState.v1=[sx,sy];
  else spanState.v2=[sx,sy];
  updateSpan();
});
document.addEventListener('mouseup',()=>{spanState.dragging=false;spanState.dragTarget=null;});
// Touch support
document.addEventListener('touchstart',e=>{
  const c=document.getElementById('span-canvas');
  if(!c||e.target!==c)return;
  const touch=e.touches[0];
  const fakeE={clientX:touch.clientX,clientY:touch.clientY,target:c};
  const[mx,my]=spanGetCanvasCoords(fakeE,c);
  const cx=c.width/2,cy=c.height/2,scale=c.width/14;
  const[sx1,sy1]=spanToScreen(spanState.v1[0],spanState.v1[1],cx,cy,scale);
  const[sx2,sy2]=spanToScreen(spanState.v2[0],spanState.v2[1],cx,cy,scale);
  if(Math.hypot(mx-sx1,my-sy1)<30){spanState.dragging=true;spanState.dragTarget='v1';e.preventDefault();}
  else if(Math.hypot(mx-sx2,my-sy2)<30){spanState.dragging=true;spanState.dragTarget='v2';e.preventDefault();}
},{passive:false});
document.addEventListener('touchmove',e=>{
  if(!spanState.dragging)return;
  e.preventDefault();
  const c=document.getElementById('span-canvas');if(!c)return;
  const touch=e.touches[0];
  const[mx,my]=spanGetCanvasCoords({clientX:touch.clientX,clientY:touch.clientY},c);
  const cx=c.width/2,cy=c.height/2,scale=c.width/14;
  const[wx,wy]=spanToWorld(mx,my,cx,cy,scale);
  if(spanState.dragTarget==='v1')spanState.v1=[wx,wy];
  else spanState.v2=[wx,wy];
  updateSpan();
},{passive:false});
document.addEventListener('touchend',()=>{spanState.dragging=false;spanState.dragTarget=null;});

function spanResetVectors(){spanState.v1=[2,1];spanState.v2=[-1,1.5];document.getElementById('span-c1').value=1;document.getElementById('span-c2').value=1;updateSpan();}
function spanSetDependent(){spanState.v1=[2,1];spanState.v2=[4,2];document.getElementById('span-c1').value=1;document.getElementById('span-c2').value=0.5;updateSpan();}
function spanAnimateToTarget(){
  const c1Target=parseFloat(document.getElementById('span-c1').value)||0;
  const c2Target=parseFloat(document.getElementById('span-c2').value)||0;
  spanState.animC1From=0;spanState.animC2From=0;
  spanState.animC1To=c1Target;spanState.animC2To=c2Target;
  spanState.animT=0;spanState.animating=true;
  spanAnimFrame();
}
function spanAnimFrame(){
  if(!spanState.animating)return;
  spanState.animT+=0.012;
  if(spanState.animT>=1){spanState.animT=1;spanState.animating=false;}
  const ease=spanState.animT<0.5?2*spanState.animT*spanState.animT:1-Math.pow(-2*spanState.animT+2,2)/2;
  const ac1=spanState.animC1From+(spanState.animC1To-spanState.animC1From)*ease;
  const ac2=spanState.animC2From+(spanState.animC2To-spanState.animC2From)*ease;
  spanDrawCanvas(ac1,ac2);
  if(spanState.animating)spanState.animId=requestAnimationFrame(spanAnimFrame);
}
// === Fill Plane Animation (3B1B style expanding coverage) ===
let spanFillState={active:false,t:0,animId:null,maxRing:0,cells:[]};
function spanFillPlane(){
  const v1=spanState.v1,v2=spanState.v2;
  const det=v1[0]*v2[1]-v1[1]*v2[0];
  if(Math.abs(det)<0.05){
    // dependent — show line sweep instead
    spanFillState.active=true;spanFillState.t=0;
    spanFillState.cells=[];spanFillState.maxRing=1;
    spanFillLineAnim();
    return;
  }
  // Build cells sorted by distance ring from origin
  spanFillState.cells=[];
  const maxR=8;
  for(let i=-maxR;i<=maxR;i++){
    for(let j=-maxR;j<=maxR;j++){
      const ring=Math.max(Math.abs(i),Math.abs(j));
      const cx=i*v1[0]+j*v2[0], cy_=i*v1[1]+j*v2[1];
      // corners of parallelogram cell
      const c00=[i*v1[0]+j*v2[0],i*v1[1]+j*v2[1]];
      const c10=[(i+1)*v1[0]+j*v2[0],(i+1)*v1[1]+j*v2[1]];
      const c11=[(i+1)*v1[0]+(j+1)*v2[0],(i+1)*v1[1]+(j+1)*v2[1]];
      const c01=[i*v1[0]+(j+1)*v2[0],i*v1[1]+(j+1)*v2[1]];
      // color based on i,j
      const hue=(((i+maxR)*17+(j+maxR)*31)%360+360)%360;
      spanFillState.cells.push({ring,i,j,c00,c10,c11,c01,hue});
    }
  }
  spanFillState.cells.sort((a,b)=>a.ring-b.ring||(a.i+a.j)-(b.i+b.j));
  spanFillState.maxRing=maxR;
  spanFillState.active=true;spanFillState.t=0;
  spanState.animating=false;
  spanFillAnimFrame();
}
function spanFillAnimFrame(){
  if(!spanFillState.active)return;
  spanFillState.t+=0.008;
  if(spanFillState.t>=1){spanFillState.t=1;spanFillState.active=false;}
  spanFillDraw(spanFillState.t);
  if(spanFillState.active)spanFillState.animId=requestAnimationFrame(spanFillAnimFrame);
}
function spanFillLineAnim(){
  if(!spanFillState.active)return;
  spanFillState.t+=0.015;
  if(spanFillState.t>=1){spanFillState.t=1;spanFillState.active=false;}
  spanFillLineDraw(spanFillState.t);
  if(spanFillState.active)spanFillState.animId=requestAnimationFrame(spanFillLineAnim);
}
function spanFillLineDraw(t){
  const canvas=document.getElementById('span-canvas');
  if(!canvas)return;
  const ctx=canvas.getContext('2d');
  const w=canvas.clientWidth||600;const h=450;
  canvas.width=w*2;canvas.height=h*2;canvas.style.height=h+'px';
  ctx.scale(2,2);
  const cxC=w/2,cyC=h/2,scale=w/14;
  const v1=spanState.v1;
  ctx.fillStyle=SPAN_BG;ctx.fillRect(0,0,w,h);
  // Standard grid
  ctx.strokeStyle=SPAN_GRID;ctx.lineWidth=0.5;
  for(let i=-7;i<=7;i++){
    ctx.beginPath();ctx.moveTo(cxC+i*scale,0);ctx.lineTo(cxC+i*scale,h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,cyC+i*scale);ctx.lineTo(w,cyC+i*scale);ctx.stroke();
  }
  ctx.strokeStyle=SPAN_AXIS;ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(0,cyC);ctx.lineTo(w,cyC);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cxC,0);ctx.lineTo(cxC,h);ctx.stroke();
  // Animated line sweep
  const len=Math.hypot(v1[0],v1[1]);
  if(len>0.01){
    const ease=t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;
    const reach=ease*8;
    const ux=v1[0]/len,uy=v1[1]/len;
    // Glow
    for(let k=0;k<3;k++){
      const alpha=0.08*(3-k);
      const lw=12-k*4;
      ctx.strokeStyle='rgba(255,255,0,'+alpha+')';ctx.lineWidth=lw;
      ctx.beginPath();
      ctx.moveTo(cxC-ux*reach*scale,cyC+uy*reach*scale);
      ctx.lineTo(cxC+ux*reach*scale,cyC-uy*reach*scale);
      ctx.stroke();
    }
    ctx.strokeStyle='rgba(255,255,0,0.8)';ctx.lineWidth=2.5;
    ctx.beginPath();
    ctx.moveTo(cxC-ux*reach*scale,cyC+uy*reach*scale);
    ctx.lineTo(cxC+ux*reach*scale,cyC-uy*reach*scale);
    ctx.stroke();
    // Dots along line
    for(let k=-Math.floor(reach);k<=Math.floor(reach);k++){
      const dotT=Math.abs(k)/reach;
      if(dotT>ease)continue;
      const px=cxC+k*v1[0]*scale,py=cyC-k*v1[1]*scale;
      ctx.fillStyle='rgba(255,255,0,'+(0.8*(1-dotT*0.3))+')';
      ctx.beginPath();ctx.arc(px,py,3,0,Math.PI*2);ctx.fill();
    }
  }
  // Vectors
  const[sv1x,sv1y]=spanToScreen(spanState.v1[0],spanState.v1[1],cxC,cyC,scale);
  const[sv2x,sv2y]=spanToScreen(spanState.v2[0],spanState.v2[1],cxC,cyC,scale);
  spanDrawArrow(ctx,cxC,cyC,sv1x,sv1y,SPAN_V1,3,12);
  spanDrawArrow(ctx,cxC,cyC,sv2x,sv2y,SPAN_V2,3,12);
  // Info
  const info=document.getElementById('span-info');
  if(info){
    const pct=Math.round(t*100);
    info.innerHTML='<div style="color:#ffff00;font-weight:700;font-size:15px">⚠ 線性相依 — Span 只能覆蓋一條直線 ('+pct+'%)</div>'
      +'<div style="color:var(--text2);margin-top:4px">v₂ 是 v₁ 的倍數，無法張開到第二個維度</div>';
  }
}
function spanFillDraw(t){
  const canvas=document.getElementById('span-canvas');
  if(!canvas)return;
  const ctx=canvas.getContext('2d');
  const w=canvas.clientWidth||600;const h=450;
  canvas.width=w*2;canvas.height=h*2;canvas.style.height=h+'px';
  ctx.scale(2,2);
  const cxC=w/2,cyC=h/2,scale=w/14;
  const v1=spanState.v1,v2=spanState.v2;

  ctx.fillStyle=SPAN_BG;ctx.fillRect(0,0,w,h);

  // Standard grid (very subtle)
  ctx.strokeStyle='rgba(42,42,74,0.5)';ctx.lineWidth=0.5;
  for(let i=-7;i<=7;i++){
    ctx.beginPath();ctx.moveTo(cxC+i*scale,0);ctx.lineTo(cxC+i*scale,h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,cyC+i*scale);ctx.lineTo(w,cyC+i*scale);ctx.stroke();
  }
  ctx.strokeStyle=SPAN_AXIS;ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(0,cyC);ctx.lineTo(w,cyC);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cxC,0);ctx.lineTo(cxC,h);ctx.stroke();

  // Ease
  const ease=t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;
  const currentRing=ease*spanFillState.maxRing;

  // Draw filled parallelogram cells with wave expansion
  const cells=spanFillState.cells;
  for(let ci=0;ci<cells.length;ci++){
    const cell=cells[ci];
    if(cell.ring>currentRing+0.5)continue;
    // Fade in based on ring
    const cellProgress=Math.max(0,Math.min(1,(currentRing-cell.ring+1)));
    const cellEase=cellProgress<0.5?2*cellProgress*cellProgress:1-Math.pow(-2*cellProgress+2,2)/2;
    if(cellEase<0.01)continue;
    const alpha=cellEase*0.18;
    const[sx0,sy0]=spanToScreen(cell.c00[0],cell.c00[1],cxC,cyC,scale);
    const[sx1,sy1]=spanToScreen(cell.c10[0],cell.c10[1],cxC,cyC,scale);
    const[sx2,sy2]=spanToScreen(cell.c11[0],cell.c11[1],cxC,cyC,scale);
    const[sx3,sy3]=spanToScreen(cell.c01[0],cell.c01[1],cxC,cyC,scale);
    // Skip if entirely off screen
    if(Math.min(sx0,sx1,sx2,sx3)>w+20||Math.max(sx0,sx1,sx2,sx3)<-20)continue;
    if(Math.min(sy0,sy1,sy2,sy3)>h+20||Math.max(sy0,sy1,sy2,sy3)<-20)continue;
    // Fill cell
    ctx.fillStyle='hsla('+cell.hue+',60%,55%,'+alpha+')';
    ctx.beginPath();ctx.moveTo(sx0,sy0);ctx.lineTo(sx1,sy1);ctx.lineTo(sx2,sy2);ctx.lineTo(sx3,sy3);ctx.closePath();ctx.fill();
    // Cell border
    if(cellEase>0.3){
      ctx.strokeStyle='hsla('+cell.hue+',60%,65%,'+(cellEase*0.15)+')';
      ctx.lineWidth=0.8;ctx.stroke();
    }
  }

  // Expanding grid lines along v1 and v2
  const gridR=Math.ceil(currentRing);
  ctx.globalAlpha=Math.min(1,ease*2);
  for(let j=-gridR;j<=gridR;j++){
    const lineProgress=Math.max(0,Math.min(1,(currentRing-Math.abs(j)+1)));
    if(lineProgress<0.01)continue;
    const la=lineProgress*0.25;
    // v1-direction lines
    ctx.strokeStyle='rgba(131,193,103,'+la+')';ctx.lineWidth=0.8;
    ctx.beginPath();
    const b1x=j*v2[0],b1y=j*v2[1];
    const ext=lineProgress*8;
    const[lsx1,lsy1]=spanToScreen(b1x-ext*v1[0],b1y-ext*v1[1],cxC,cyC,scale);
    const[lsx2,lsy2]=spanToScreen(b1x+ext*v1[0],b1y+ext*v1[1],cxC,cyC,scale);
    ctx.moveTo(lsx1,lsy1);ctx.lineTo(lsx2,lsy2);ctx.stroke();
    // v2-direction lines
    ctx.strokeStyle='rgba(252,98,85,'+la+')';
    ctx.beginPath();
    const b2x=j*v1[0],b2y=j*v1[1];
    const[lsx3,lsy3]=spanToScreen(b2x-ext*v2[0],b2y-ext*v2[1],cxC,cyC,scale);
    const[lsx4,lsy4]=spanToScreen(b2x+ext*v2[0],b2y+ext*v2[1],cxC,cyC,scale);
    ctx.moveTo(lsx3,lsy3);ctx.lineTo(lsx4,lsy4);ctx.stroke();
  }
  ctx.globalAlpha=1.0;

  // Lattice points with glow, expanding outward
  for(let i=-gridR;i<=gridR;i++){
    for(let j=-gridR;j<=gridR;j++){
      const ring=Math.max(Math.abs(i),Math.abs(j));
      if(ring>currentRing+0.3)continue;
      const ptProgress=Math.max(0,Math.min(1,(currentRing-ring+0.8)));
      if(ptProgress<0.01)continue;
      const px=i*v1[0]+j*v2[0],py=i*v1[1]+j*v2[1];
      const[spx,spy]=spanToScreen(px,py,cxC,cyC,scale);
      if(spx<-10||spx>w+10||spy<-10||spy>h+10)continue;
      const ptEase=ptProgress<0.5?2*ptProgress*ptProgress:1-Math.pow(-2*ptProgress+2,2)/2;
      const r=ptEase*3.5;
      const hue=(((i+8)*17+(j+8)*31)%360+360)%360;
      // Glow
      ctx.shadowColor='hsla('+hue+',70%,65%,0.8)';ctx.shadowBlur=ptEase*8;
      ctx.fillStyle='hsla('+hue+',65%,70%,'+(ptEase*0.9)+')';
      ctx.beginPath();ctx.arc(spx,spy,r,0,Math.PI*2);ctx.fill();
      ctx.shadowBlur=0;
    }
  }

  // Draw basis vectors on top
  const[sv1x,sv1y]=spanToScreen(v1[0],v1[1],cxC,cyC,scale);
  const[sv2x,sv2y]=spanToScreen(v2[0],v2[1],cxC,cyC,scale);
  spanDrawArrow(ctx,cxC,cyC,sv1x,sv1y,SPAN_V1,3.5,14);
  spanDrawArrow(ctx,cxC,cyC,sv2x,sv2y,SPAN_V2,3.5,14);
  // Endpoints glow
  ctx.shadowColor=SPAN_V1;ctx.shadowBlur=15;
  ctx.fillStyle=SPAN_V1;ctx.beginPath();ctx.arc(sv1x,sv1y,5,0,Math.PI*2);ctx.fill();
  ctx.shadowColor=SPAN_V2;
  ctx.fillStyle=SPAN_V2;ctx.beginPath();ctx.arc(sv2x,sv2y,5,0,Math.PI*2);ctx.fill();
  ctx.shadowBlur=0;
  // Labels
  ctx.font='bold 15px "Noto Sans TC", sans-serif';ctx.textAlign='left';
  ctx.fillStyle=SPAN_V1;ctx.fillText('v₁',sv1x+12,sv1y-12);
  ctx.fillStyle=SPAN_V2;ctx.fillText('v₂',sv2x+12,sv2y-12);
  // Origin
  ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(cxC,cyC,4,0,Math.PI*2);ctx.fill();

  // Progress info
  const info=document.getElementById('span-info');
  if(info){
    const pct=Math.round(t*100);
    const ringCount=Math.floor(currentRing);
    const pointCount=(2*ringCount+1)*(2*ringCount+1);
    info.innerHTML='<div style="color:#ffff00;font-weight:700;font-size:15px">✦ Span{v₁, v₂} = ℝ² — 正在鋪滿整個平面 ('+pct+'%)</div>'
      +'<div style="color:var(--text2);margin-top:4px">已展開 <span style="color:#83c167">'+ringCount+'</span> 圈 · <span style="color:#7ec8e3">'+pointCount+'</span> 個格點 · 每個色塊 = 一個平行四邊形基本單元</div>'
      +'<div style="color:var(--text3);margin-top:4px;font-size:12px">任意 (c₁, c₂) ∈ ℝ² 都能到達平面上的每一個點</div>';
  }
}
function updateSpan(){
  spanState.animating=false;spanFillState.active=false;
  const c1=parseFloat(document.getElementById('span-c1').value)||0;
  const c2=parseFloat(document.getElementById('span-c2').value)||0;
  document.getElementById('span-c1-val').textContent=c1.toFixed(2);
  document.getElementById('span-c2-val').textContent=c2.toFixed(2);
  spanDrawCanvas(c1,c2);
}
function spanDrawArrow(ctx,x1,y1,x2,y2,color,lineW,headSize){
  const dx=x2-x1,dy=y2-y1,len=Math.hypot(dx,dy);
  if(len<1)return;
  const ux=dx/len,uy=dy/len;
  ctx.strokeStyle=color;ctx.lineWidth=lineW;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2-ux*headSize*0.5,y2-uy*headSize*0.5);ctx.stroke();
  // arrowhead
  ctx.fillStyle=color;ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2-ux*headSize-uy*headSize*0.4,y2-uy*headSize+ux*headSize*0.4);
  ctx.lineTo(x2-ux*headSize+uy*headSize*0.4,y2-uy*headSize-ux*headSize*0.4);
  ctx.closePath();ctx.fill();
}
function spanDrawDashedLine(ctx,x1,y1,x2,y2,color){
  ctx.strokeStyle=color;ctx.lineWidth=1.5;ctx.setLineDash([6,4]);
  ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();
  ctx.setLineDash([]);
}
function spanDrawCanvas(c1,c2){
  const canvas=document.getElementById('span-canvas');
  if(!canvas)return;
  const ctx=canvas.getContext('2d');
  const w=canvas.clientWidth||canvas.parentElement.clientWidth||600;
  const h=450;
  canvas.width=w*2;canvas.height=h*2;canvas.style.height=h+'px';
  ctx.scale(2,2); // Retina sharpness
  const cx=w/2,cy=h/2,scale=w/14;
  const v1=spanState.v1,v2=spanState.v2;
  const det=v1[0]*v2[1]-v1[1]*v2[0];
  const isIndep=Math.abs(det)>0.05;

  // === Background ===
  ctx.fillStyle=SPAN_BG;ctx.fillRect(0,0,w,h);

  // === Transformed grid (3B1B style: grid formed by v1 and v2) ===
  if(isIndep){
    // Draw parallelogram lattice
    ctx.globalAlpha=0.08;
    for(let i=-8;i<=8;i++){
      for(let j=-8;j<=8;j++){
        const px=cx+(i*v1[0]+j*v2[0])*scale;
        const py=cy-(i*v1[1]+j*v2[1])*scale;
        if(px<-50||px>w+50||py<-50||py>h+50)continue;
        ctx.fillStyle='#7ec8e3';
        ctx.beginPath();ctx.arc(px,py,2,0,Math.PI*2);ctx.fill();
      }
    }
    // Grid lines along v1 direction
    ctx.strokeStyle='rgba(131,193,103,0.12)';ctx.lineWidth=1;
    for(let j=-6;j<=6;j++){
      ctx.beginPath();
      const bx=j*v2[0],by=j*v2[1];
      const[sx1,sy1]=spanToScreen(bx-6*v1[0],by-6*v1[1],cx,cy,scale);
      const[sx2,sy2]=spanToScreen(bx+6*v1[0],by+6*v1[1],cx,cy,scale);
      ctx.moveTo(sx1,sy1);ctx.lineTo(sx2,sy2);ctx.stroke();
    }
    // Grid lines along v2 direction
    ctx.strokeStyle='rgba(252,98,85,0.12)';
    for(let i=-6;i<=6;i++){
      ctx.beginPath();
      const bx=i*v1[0],by=i*v1[1];
      const[sx1,sy1]=spanToScreen(bx-6*v2[0],by-6*v2[1],cx,cy,scale);
      const[sx2,sy2]=spanToScreen(bx+6*v2[0],by+6*v2[1],cx,cy,scale);
      ctx.moveTo(sx1,sy1);ctx.lineTo(sx2,sy2);ctx.stroke();
    }
    ctx.globalAlpha=1.0;
  }else{
    // Dependent: show span as a glowing line
    ctx.globalAlpha=1.0;
    const len=Math.hypot(v1[0],v1[1]);
    if(len>0.01){
      const ux=v1[0]/len,uy=v1[1]/len;
      const grad=ctx.createLinearGradient(
        cx-ux*w,cy+uy*w,cx+ux*w,cy-uy*w
      );
      grad.addColorStop(0,'rgba(255,255,0,0)');
      grad.addColorStop(0.3,'rgba(255,255,0,0.15)');
      grad.addColorStop(0.5,'rgba(255,255,0,0.3)');
      grad.addColorStop(0.7,'rgba(255,255,0,0.15)');
      grad.addColorStop(1,'rgba(255,255,0,0)');
      ctx.strokeStyle=grad;ctx.lineWidth=8;
      ctx.beginPath();
      ctx.moveTo(cx-ux*w,cy+uy*w);ctx.lineTo(cx+ux*w,cy-uy*w);
      ctx.stroke();
      ctx.strokeStyle='rgba(255,255,0,0.6)';ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(cx-ux*w,cy+uy*w);ctx.lineTo(cx+ux*w,cy-uy*w);
      ctx.stroke();
    }
  }

  // === Standard grid (subtle) ===
  ctx.strokeStyle=SPAN_GRID;ctx.lineWidth=0.5;
  for(let i=-7;i<=7;i++){
    ctx.beginPath();ctx.moveTo(cx+i*scale,0);ctx.lineTo(cx+i*scale,h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,cy+i*scale);ctx.lineTo(w,cy+i*scale);ctx.stroke();
  }
  // Axes
  ctx.strokeStyle=SPAN_AXIS;ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(0,cy);ctx.lineTo(w,cy);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx,0);ctx.lineTo(cx,h);ctx.stroke();
  // Axis labels
  ctx.fillStyle='rgba(255,255,255,0.3)';ctx.font='11px JetBrains Mono';ctx.textAlign='center';
  for(let i=-6;i<=6;i++){
    if(i===0)continue;
    ctx.fillText(i,cx+i*scale,cy+16);
    ctx.fillText(i,cx-18,cy-i*scale+4);
  }
  // Origin
  ctx.fillStyle='rgba(255,255,255,0.5)';ctx.font='bold 12px JetBrains Mono';
  ctx.fillText('O',cx-12,cy+16);

  // === Component vectors (dashed parallelogram) ===
  const cv1=[c1*v1[0],c1*v1[1]]; // c1*v1
  const cv2=[c2*v2[0],c2*v2[1]]; // c2*v2
  const result=[cv1[0]+cv2[0],cv1[1]+cv2[1]];
  const[scv1x,scv1y]=spanToScreen(cv1[0],cv1[1],cx,cy,scale);
  const[scv2x,scv2y]=spanToScreen(cv2[0],cv2[1],cx,cy,scale);
  const[srx,sry]=spanToScreen(result[0],result[1],cx,cy,scale);

  // Parallelogram fill
  if(Math.abs(c1)>0.01&&Math.abs(c2)>0.01){
    ctx.fillStyle='rgba(255,255,0,0.04)';
    ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(scv1x,scv1y);ctx.lineTo(srx,sry);ctx.lineTo(scv2x,scv2y);ctx.closePath();ctx.fill();
    // Dashed lines forming parallelogram
    spanDrawDashedLine(ctx,scv1x,scv1y,srx,sry,SPAN_COMP);
    spanDrawDashedLine(ctx,scv2x,scv2y,srx,sry,SPAN_COMP);
  }
  // c1*v1 component arrow (green, dimmer)
  if(Math.abs(c1)>0.01){
    spanDrawArrow(ctx,cx,cy,scv1x,scv1y,'rgba(131,193,103,0.45)',2,8);
  }
  // c2*v2 component arrow (red, dimmer)
  if(Math.abs(c2)>0.01){
    spanDrawArrow(ctx,cx,cy,scv2x,scv2y,'rgba(252,98,85,0.45)',2,8);
  }

  // === Basis vectors v1, v2 (bright, with arrows) ===
  const[sv1x,sv1y]=spanToScreen(v1[0],v1[1],cx,cy,scale);
  const[sv2x,sv2y]=spanToScreen(v2[0],v2[1],cx,cy,scale);
  spanDrawArrow(ctx,cx,cy,sv1x,sv1y,SPAN_V1,3,12);
  spanDrawArrow(ctx,cx,cy,sv2x,sv2y,SPAN_V2,3,12);

  // === Result vector (yellow, bold) ===
  if(Math.hypot(result[0],result[1])>0.01){
    spanDrawArrow(ctx,cx,cy,srx,sry,SPAN_RESULT,3.5,14);
  }

  // === Draggable endpoints (glowing dots) ===
  // v1 endpoint
  ctx.beginPath();ctx.arc(sv1x,sv1y,7,0,Math.PI*2);
  ctx.fillStyle=SPAN_V1;ctx.fill();
  ctx.shadowColor=SPAN_V1;ctx.shadowBlur=12;
  ctx.beginPath();ctx.arc(sv1x,sv1y,4,0,Math.PI*2);ctx.fill();
  ctx.shadowBlur=0;
  // v2 endpoint
  ctx.beginPath();ctx.arc(sv2x,sv2y,7,0,Math.PI*2);
  ctx.fillStyle=SPAN_V2;ctx.fill();
  ctx.shadowColor=SPAN_V2;ctx.shadowBlur=12;
  ctx.beginPath();ctx.arc(sv2x,sv2y,4,0,Math.PI*2);ctx.fill();
  ctx.shadowBlur=0;
  // Result endpoint
  if(Math.hypot(result[0],result[1])>0.01){
    ctx.beginPath();ctx.arc(srx,sry,6,0,Math.PI*2);
    ctx.fillStyle=SPAN_RESULT;ctx.fill();
    ctx.shadowColor=SPAN_RESULT;ctx.shadowBlur=10;
    ctx.beginPath();ctx.arc(srx,sry,3,0,Math.PI*2);ctx.fill();
    ctx.shadowBlur=0;
  }

  // === Labels ===
  ctx.font='bold 14px "Noto Sans TC", sans-serif';ctx.textAlign='left';
  ctx.fillStyle=SPAN_V1;
  ctx.fillText('v₁',sv1x+10,sv1y-10);
  ctx.fillStyle=SPAN_V2;
  ctx.fillText('v₂',sv2x+10,sv2y-10);
  if(Math.hypot(result[0],result[1])>0.3){
    ctx.fillStyle=SPAN_RESULT;ctx.font='bold 13px "Noto Sans TC", sans-serif';
    ctx.fillText(c1.toFixed(1)+'v₁+'+c2.toFixed(1)+'v₂',srx+10,sry-10);
  }
  // Component labels
  if(Math.abs(c1)>0.3){
    ctx.fillStyle='rgba(131,193,103,0.5)';ctx.font='11px JetBrains Mono';
    ctx.fillText(c1.toFixed(1)+'v₁',(cx+scv1x)/2+8,(cy+scv1y)/2-6);
  }
  if(Math.abs(c2)>0.3){
    ctx.fillStyle='rgba(252,98,85,0.5)';ctx.font='11px JetBrains Mono';
    ctx.fillText(c2.toFixed(1)+'v₂',(cx+scv2x)/2+8,(cy+scv2y)/2-6);
  }

  // === Info panel ===
  const info=document.getElementById('span-info');
  if(info){
    const statusColor=isIndep?SPAN_V1:'#ffff00';
    const statusText=isIndep?'✓ 線性獨立 — Span{v₁,v₂} = ℝ²（鋪滿整個平面）':'⚠ 線性相依 — Span 退化為一條直線';
    const detVal=det.toFixed(3);
    info.innerHTML='<div style="display:flex;justify-content:space-between;flex-wrap:wrap;gap:8px">'
      +'<span><span style="color:'+SPAN_V1+'">v₁</span> = ['+v1[0].toFixed(2)+', '+v1[1].toFixed(2)+']</span>'
      +'<span><span style="color:'+SPAN_V2+'">v₂</span> = ['+v2[0].toFixed(2)+', '+v2[1].toFixed(2)+']</span>'
      +'<span>det = '+detVal+'</span></div>'
      +'<div style="margin-top:6px"><span style="color:'+SPAN_RESULT+'">線性組合</span> = ['+result[0].toFixed(2)+', '+result[1].toFixed(2)+']</div>'
      +'<div style="margin-top:6px;color:'+statusColor+';font-weight:700">'+statusText+'</div>';
  }
}

// 4. Gaussian Elimination Animation
let gaussAnimState={step:0,maxSteps:0,matrixHistory:[],operations:[],playing:false,animId:null};
function gaussAnimStep(){
  if(gaussAnimState.step<gaussAnimState.maxSteps){
    gaussAnimState.step++;
    gaussAnimDrawCanvas();
  }
}
function gaussAnimAuto(){
  if(!gaussAnimState.playing){
    gaussAnimState.playing=true;
    gaussAnimAutoPlay();
  }
}
function gaussAnimAutoPlay(){
  if(gaussAnimState.playing&&gaussAnimState.step<gaussAnimState.maxSteps){
    gaussAnimState.step++;
    gaussAnimDrawCanvas();
    setTimeout(gaussAnimAutoPlay,600);
  }else{
    gaussAnimState.playing=false;
    // Auto-loop: reset and replay after pause
    setTimeout(()=>{gaussAnimReset();setTimeout(gaussAnimAuto,400);},2000);
  }
}
function gaussAnimReset(){
  gaussAnimState.step=0;
  gaussAnimState.playing=false;
  const inp=[...document.querySelectorAll('#gauss-anim-in input')].map(i=>parseFloat(i.value)||0);
  let M=[[inp[0],inp[1],inp[2],inp[3]],[inp[4],inp[5],inp[6],inp[7]],[inp[8],inp[9],inp[10],inp[11]]];
  gaussAnimState.matrixHistory=[JSON.parse(JSON.stringify(M))];
  gaussAnimState.operations=[];
  for(let col=0;col<3;col++){
    let pivot=-1;for(let r=col;r<3;r++){if(Math.abs(M[r][col])>1e-10){pivot=r;break;}}
    if(pivot<0)continue;
    if(pivot!==col){[M[col],M[pivot]]=[M[pivot],M[col]];gaussAnimState.matrixHistory.push(JSON.parse(JSON.stringify(M)));gaussAnimState.operations.push('交換 R'+(col+1)+' 與 R'+(pivot+1));}
    for(let r=col+1;r<3;r++){
      if(Math.abs(M[r][col])<1e-10)continue;
      const f=-M[r][col]/M[col][col];
      for(let c=0;c<4;c++)M[r][c]+=f*M[col][c];M[r][col]=0;
      gaussAnimState.matrixHistory.push(JSON.parse(JSON.stringify(M)));
      gaussAnimState.operations.push('R'+(r+1)+' + '+f.toFixed(2)+'R'+(col+1));
    }
  }
  gaussAnimState.maxSteps=gaussAnimState.matrixHistory.length-1;
  gaussAnimDrawCanvas();
}
function gaussAnimDrawCanvas(){
  const c=document.getElementById('gauss-anim-canvas');
  if(!c||gaussAnimState.matrixHistory.length===0)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||c.parentElement.clientWidth||600;
  const h=350;
  c.width=w*2;c.height=h*2;c.style.height=h+'px';
  ctx.scale(2,2);

  // Background
  ctx.fillStyle='#1b1b2f';ctx.fillRect(0,0,w,h);

  const mat=gaussAnimState.matrixHistory[gaussAnimState.step];
  const cellW=w/6.5,cellH=h/4.5;
  const sx=w/12,sy=h/10;

  // Draw matrix cells as rounded rectangles
  for(let i=0;i<3;i++){
    for(let j=0;j<4;j++){
      const val=mat[i][j];
      const x=sx+j*cellW,y=sy+i*cellH;
      const isAugmented=j===3;
      const borderColor=isAugmented?'rgba(232,179,57,0.6)':'rgba(88,196,221,0.6)';

      // Rounded rectangle background
      ctx.fillStyle=Math.abs(val)<0.01?'rgba(80,80,100,0.2)':'rgba(80,80,100,0.05)';
      ctx.beginPath();
      ctx.roundRect(x+4,y+4,cellW-8,cellH-8,4);
      ctx.fill();

      // Colored border
      ctx.strokeStyle=borderColor;ctx.lineWidth=1.5;
      ctx.beginPath();
      ctx.roundRect(x+4,y+4,cellW-8,cellH-8,4);
      ctx.stroke();

      // Text
      ctx.fillStyle=Math.abs(val)<0.01?'rgba(200,192,176,0.4)':'#c8c0b0';
      ctx.font='bold 14px JetBrains Mono';ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.fillText(val.toFixed(2),x+cellW/2,y+cellH/2+2);
    }
  }

  // Divider line between A and b
  ctx.strokeStyle='rgba(232,179,57,0.5)';ctx.lineWidth=2;
  ctx.setLineDash([6,3]);
  ctx.beginPath();
  ctx.moveTo(sx+3*cellW,sy);
  ctx.lineTo(sx+3*cellW,sy+3*cellH);
  ctx.stroke();
  ctx.setLineDash([]);

  // Matrix label
  ctx.fillStyle='rgba(200,192,176,0.6)';ctx.font='11px JetBrains Mono';ctx.textAlign='left';
  ctx.fillText('[A | b]',sx+w/30,sy-8);

  // Highlight pivot element if exists
  if(gaussAnimState.step>0&&gaussAnimState.step<=gaussAnimState.matrixHistory.length){
    // Find pivot in current matrix
    for(let col=0;col<3;col++){
      for(let r=col;r<3;r++){
        if(Math.abs(mat[r][col])>1e-10){
          const x=sx+col*cellW+4,y=sy+r*cellH+4;
          ctx.shadowColor='rgba(255,255,0,0.8)';ctx.shadowBlur=10;
          ctx.strokeStyle='#ffff00';ctx.lineWidth=2.5;
          ctx.beginPath();
          ctx.roundRect(x,y,cellW-8,cellH-8,4);
          ctx.stroke();
          ctx.shadowBlur=0;
          break;
        }
      }
    }
  }

  const info=document.getElementById('gauss-anim-info');
  if(info){
    let txt='<span style="color:#58c4dd;font-weight:700">步驟 '+gaussAnimState.step+' / '+gaussAnimState.maxSteps+'</span>';
    if(gaussAnimState.step>0&&gaussAnimState.step<=gaussAnimState.operations.length){
      txt+=' &nbsp; 操作: <span style="color:#ffff00">'+gaussAnimState.operations[gaussAnimState.step-1]+'</span>';
    }
    info.innerHTML=txt;
  }
}

// 5. Eigenvalue — 6 vectors contrast: eigenvectors vs general vectors
let eigAnimState={t:0,playing:false,animId:null,matrix:'sym',eigenInfo:null};

function getMatrixByKey(mat){
  const s=Math.sqrt(2)/2;
  switch(mat){
    case 'sym':return [[2,1],[1,2]];
    case 'diag':return [[3,0],[0,-1]];
    case 'scale':return [[2,0],[0,0.5]];
    case 'shear':return [[1,0.5],[0,1]];
    case 'rot':return [[s,-s],[s,s]];
    default:return [[1,0],[0,1]];
  }
}
function computeEigen(A){
  const a=A[0][0],b=A[0][1],cc=A[1][0],d=A[1][1];
  const tr=a+d,det=a*d-b*cc,disc=tr*tr-4*det;
  if(disc<0) return {vals:[],vecs:[],complex:true,re:tr/2,im:Math.sqrt(-disc)/2};
  const sq=Math.sqrt(Math.max(0,disc));
  const l1=(tr+sq)/2,l2=(tr-sq)/2;
  function ev(lam){
    let v=[1,0];
    if(Math.abs(b)>1e-10) v=[b,lam-a];
    else if(Math.abs(cc)>1e-10) v=[lam-d,cc];
    const len=Math.hypot(v[0],v[1]);
    return len>1e-10?[v[0]/len,v[1]/len]:v;
  }
  return {vals:[l1,l2],vecs:[ev(l1),ev(l2)],complex:false};
}
function updateEigAnim(){ eigAnimReset(); }
function eigAnimTransform(){
  eigAnimState.t=0; eigAnimState.playing=true; eigAnimateDraw();
}
function eigAnimReset(){
  const sel=document.getElementById('eig-matrix-select');
  eigAnimState.matrix=sel?sel.value:'sym';
  eigAnimState.eigenInfo=computeEigen(getMatrixByKey(eigAnimState.matrix));
  eigAnimState.t=0; eigAnimState.playing=false;
  eigAnimDrawEig(0);
}
function eigAnimateDraw(){
  if(!eigAnimState.playing)return;
  eigAnimState.t+=0.006;
  if(eigAnimState.t>2.2) eigAnimState.t=0;
  eigAnimDrawEig(eigAnimState.t);
  eigAnimState.animId=requestAnimationFrame(eigAnimateDraw);
}

function eigAnimDrawEig(rawT){
  const c=document.getElementById('eig-canvas'); if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||c.parentElement.clientWidth||700, h=420;
  c.width=w*2; c.height=h*2; c.style.height=h+'px'; ctx.scale(2,2);
  ctx.fillStyle='#1b1b2f'; ctx.fillRect(0,0,w,h);

  const A=getMatrixByKey(eigAnimState.matrix);
  const eig=eigAnimState.eigenInfo;
  const cx0=w/2, cy0=h/2, sc=70;

  // Animation progress: 0→0.8 transform, 0.8→2.2 hold
  function ease(x){return x<0.5?2*x*x:1-Math.pow(-2*x+2,2)/2;}
  const t=Math.min(rawT/0.8,1);
  const et=ease(t);

  // --- Grid ---
  ctx.strokeStyle='#2a2a4a'; ctx.lineWidth=0.4;
  for(let i=-4;i<=4;i++){
    ctx.beginPath(); ctx.moveTo(cx0+i*sc,0); ctx.lineTo(cx0+i*sc,h); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,cy0+i*sc); ctx.lineTo(w,cy0+i*sc); ctx.stroke();
  }
  ctx.strokeStyle='#4a4a7a'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(0,cy0); ctx.lineTo(w,cy0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx0,0); ctx.lineTo(cx0,h); ctx.stroke();

  // Build the 6 vectors: 2 eigenvectors + 4 general
  var allVecs=[];
  if(!eig.complex && eig.vecs.length>=2){
    allVecs.push({v:eig.vecs[0], isEig:true, idx:0});
    allVecs.push({v:eig.vecs[1], isEig:true, idx:1});
  }
  // 4 general directions (normalized, chosen to not overlap eigenvectors)
  var genDirs=[[1,0.3],[0.3,1],[-0.8,0.5],[-0.3,-1]];
  genDirs.forEach(function(g,gi){
    var len=Math.hypot(g[0],g[1]);
    allVecs.push({v:[g[0]/len,g[1]/len], isEig:false, idx:gi});
  });

  // Draw each vector
  allVecs.forEach(function(item){
    var vx=item.v[0], vy=item.v[1];
    var tvx=A[0][0]*vx+A[0][1]*vy, tvy=A[1][0]*vx+A[1][1]*vy;
    // Interpolated position
    var ix=vx+(tvx-vx)*et, iy=vy+(tvy-vy)*et;

    if(item.isEig){
      // === EIGENVECTOR ===
      var col=item.idx===0?'#fc6255':'#58c4dd';
      var name=item.idx===0?'v₁':'v₂';
      var lam=eig.vals[item.idx];

      // Ghost: original position (dashed)
      if(et>0.05){
        ctx.setLineDash([4,4]); ctx.strokeStyle=col+'40'; ctx.lineWidth=1.5;
        ctx.beginPath(); ctx.moveTo(cx0,cy0); ctx.lineTo(cx0+vx*sc,cy0-vy*sc); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle=col+'40'; ctx.beginPath(); ctx.arc(cx0+vx*sc,cy0-vy*sc,3,0,Math.PI*2); ctx.fill();
      }

      // Dashed line through origin showing eigenvector direction extends
      ctx.setLineDash([6,5]); ctx.strokeStyle=col+'30'; ctx.lineWidth=0.8;
      ctx.beginPath();
      ctx.moveTo(cx0-vx*w*0.4,cy0+vy*w*0.4);
      ctx.lineTo(cx0+vx*w*0.4,cy0-vy*w*0.4);
      ctx.stroke(); ctx.setLineDash([]);

      // Bold arrow (current position)
      var px=cx0+ix*sc, py=cy0-iy*sc;
      drawArrow(ctx,cx0,cy0,px,py,col,3.5,12);

      // Glowing tip
      ctx.shadowColor=col; ctx.shadowBlur=14;
      ctx.fillStyle=col;
      ctx.beginPath(); ctx.arc(px,py,5,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur=0;

      // Labels
      ctx.font='bold 14px "JetBrains Mono"'; ctx.fillStyle=col; ctx.textAlign='left';
      var offX=vx>0?10:-50, offY=vy>0?-14:22;
      ctx.fillText(name,px+offX,py+offY);

      // Av = λv equation (fade in)
      if(et>0.3){
        var alpha=Math.min(1,(et-0.3)*3);
        ctx.globalAlpha=alpha;
        ctx.font='bold 13px "JetBrains Mono"'; ctx.fillStyle=col;
        ctx.fillText('A'+name+' = '+lam.toFixed(1)+'·'+name,px+offX,py+offY+17);

        if(et>0.6){
          ctx.font='bold 12px "Noto Sans TC"'; ctx.fillStyle='#ffff00';
          ctx.fillText('方向不變！',px+offX,py+offY+34);
          ctx.font='10px "JetBrains Mono"'; ctx.fillStyle='rgba(255,255,255,0.5)';
          if(Math.abs(lam)>1) ctx.fillText('長度 ×'+Math.abs(lam).toFixed(1),px+offX,py+offY+48);
          else if(Math.abs(lam)<1&&Math.abs(lam)>0.01) ctx.fillText('長度 ×'+Math.abs(lam).toFixed(1),px+offX,py+offY+48);
          if(lam<0) ctx.fillText('(反轉180°)',px+offX,py+offY+61);
        }
        ctx.globalAlpha=1;
      }

    } else {
      // === GENERAL VECTOR ===
      var gCol='rgba(180,180,180,0.4)';

      // Ghost: original position
      if(et>0.05){
        ctx.setLineDash([3,4]); ctx.strokeStyle='rgba(180,180,180,0.12)'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(cx0,cy0); ctx.lineTo(cx0+vx*sc,cy0-vy*sc); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle='rgba(180,180,180,0.12)';
        ctx.beginPath(); ctx.arc(cx0+vx*sc,cy0-vy*sc,2.5,0,Math.PI*2); ctx.fill();
      }

      // Curved motion trail
      if(et>0.02){
        ctx.strokeStyle='rgba(180,180,180,0.08)'; ctx.lineWidth=1;
        ctx.beginPath();
        for(var s=0;s<=20;s++){
          var st=ease(s/20*t);
          var sx=vx+(tvx-vx)*st, sy=vy+(tvy-vy)*st;
          s===0?ctx.moveTo(cx0+sx*sc,cy0-sy*sc):ctx.lineTo(cx0+sx*sc,cy0-sy*sc);
        }
        ctx.stroke();
      }

      // Arrow
      var px=cx0+ix*sc, py=cy0-iy*sc;
      drawArrow(ctx,cx0,cy0,px,py,gCol,2,9);
      ctx.fillStyle=gCol;
      ctx.beginPath(); ctx.arc(px,py,3,0,Math.PI*2); ctx.fill();

      // "方向改變" label
      if(et>0.6){
        var origAng=Math.atan2(vy,vx);
        var newAng=Math.atan2(iy,ix);
        var diff=Math.abs(origAng-newAng);
        if(diff>Math.PI) diff=2*Math.PI-diff;
        if(diff>0.08){
          var alpha2=Math.min(1,(et-0.6)*4)*0.6;
          ctx.globalAlpha=alpha2;
          ctx.font='10px "Noto Sans TC"'; ctx.fillStyle='#aaa'; ctx.textAlign='center';
          ctx.fillText('方向改變',px,py+(iy>0?14:-8));
          // Show angle change
          ctx.font='9px "JetBrains Mono"'; ctx.fillStyle='rgba(232,179,57,0.5)';
          ctx.fillText('偏轉 '+Math.round(diff*180/Math.PI)+'°',px,py+(iy>0?26:-20));
          ctx.globalAlpha=1;
        }
      }
    }
  });

  // === Central Av = λv equation when fully transformed ===
  if(et>0.85 && !eig.complex){
    var alpha3=Math.min(1,(et-0.85)*8);
    ctx.globalAlpha=alpha3;
    ctx.save();
    // Semi-transparent background box
    var boxW=260, boxH=40;
    ctx.fillStyle='rgba(27,27,47,0.85)';
    ctx.fillRect(cx0-boxW/2,h-82,boxW,boxH);
    ctx.strokeStyle='rgba(255,255,0,0.3)'; ctx.lineWidth=1;
    ctx.strokeRect(cx0-boxW/2,h-82,boxW,boxH);
    // Equation
    ctx.shadowColor='#ffff00'; ctx.shadowBlur=12;
    ctx.font='bold 20px "JetBrains Mono"'; ctx.fillStyle='#ffff00'; ctx.textAlign='center';
    ctx.fillText('Av = λv',cx0,h-56);
    ctx.restore();
    ctx.globalAlpha=1;
  }

  // --- Title ---
  ctx.textAlign='center'; ctx.font='bold 14px "Noto Sans TC"';
  if(eig.complex){
    ctx.fillStyle='#e8b339';
    ctx.fillText('複數特徵值 — 所有向量方向都改變，無特徵向量',cx0,26);
    ctx.font='12px "JetBrains Mono"'; ctx.fillStyle='#c8c0b0';
    ctx.fillText('λ = '+eig.re.toFixed(2)+' ± '+eig.im.toFixed(2)+'i',cx0,46);
  } else if(et<0.05){
    ctx.fillStyle='#c8c0b0';
    ctx.fillText('6 個向量（2 特徵向量 + 4 一般向量），即將套用矩陣 A',cx0,26);
  } else if(et<0.95){
    ctx.fillStyle='#e8b339';
    ctx.fillText('套用 A 變換中 ── 觀察哪些向量方向不變？',cx0,26);
  } else {
    ctx.fillStyle='#83c167';
    ctx.fillText('只有特徵向量方向不變（Av = λv），一般向量方向都偏轉了',cx0,26);
  }

  // --- Bottom matrix info ---
  ctx.textAlign='left'; ctx.font='11px "JetBrains Mono"'; ctx.fillStyle='rgba(200,192,176,0.5)';
  ctx.fillText('A=[['+A[0][0].toFixed(1)+','+A[0][1].toFixed(1)+'],['+A[1][0].toFixed(1)+','+A[1][1].toFixed(1)+']]',10,h-8);
  if(!eig.complex && eig.vals.length>=2){
    ctx.textAlign='right'; ctx.fillStyle='rgba(200,192,176,0.35)';
    ctx.fillText('λ₁='+eig.vals[0].toFixed(2)+'  λ₂='+eig.vals[1].toFixed(2),w-10,h-8);
  }

  // --- Info box ---
  var info=document.getElementById('eig-info');
  if(info){
    var txt='<div style="font-size:13px;line-height:1.7">';
    txt+='<div style="display:flex;gap:14px;align-items:center;flex-wrap:wrap;margin-bottom:6px">';
    txt+='<span style="color:#fc6255;font-weight:700">━ v₁ 特徵向量</span>';
    txt+='<span style="color:#58c4dd;font-weight:700">━ v₂ 特徵向量</span>';
    txt+='<span style="color:rgba(180,180,180,0.5)">━ 一般向量（方向改變）</span></div>';
    txt+='<div style="color:#ffff00;font-weight:700;font-size:14px;margin:6px 0">核心公式：Av = λv</div>';
    txt+='<div style="color:#c8c0b0;font-size:12px">矩陣 A 作用在特徵向量 v 上，結果只是 v 乘以一個常數 λ（特徵值）。方向完全不變，只有長度伸縮。其他向量則會被「偏轉」到不同方向。</div>';
    if(!eig.complex && eig.vals.length>=2){
      txt+='<div style="margin-top:8px;display:flex;gap:16px">';
      txt+='<div style="background:rgba(252,98,85,0.08);border:1px solid rgba(252,98,85,0.25);padding:4px 10px;border-radius:4px">';
      txt+='<span style="color:#fc6255;font-weight:700">λ₁='+eig.vals[0].toFixed(2)+'</span> ';
      txt+='<span style="color:rgba(200,192,176,0.5);font-size:11px">v₁=['+eig.vecs[0][0].toFixed(2)+','+eig.vecs[0][1].toFixed(2)+']</span></div>';
      txt+='<div style="background:rgba(88,196,221,0.08);border:1px solid rgba(88,196,221,0.25);padding:4px 10px;border-radius:4px">';
      txt+='<span style="color:#58c4dd;font-weight:700">λ₂='+eig.vals[1].toFixed(2)+'</span> ';
      txt+='<span style="color:rgba(200,192,176,0.5);font-size:11px">v₂=['+eig.vecs[1][0].toFixed(2)+','+eig.vecs[1][1].toFixed(2)+']</span></div>';
      txt+='</div>';
    } else if(eig.complex){
      txt+='<div style="color:#e8b339;margin-top:6px">此矩陣只有複數特徵值 λ='+eig.re.toFixed(2)+'±'+eig.im.toFixed(2)+'i，無實特徵向量。</div>';
    }
    txt+='</div>';
    info.innerHTML=txt;
  }
}

// ===== NEW ANIMATION FUNCTIONS =====

// 1. Vector Addition Animation (sec-71)
var animMatvecState={t:0,animId:null};
function animMatvecDraw(t){
  const c=document.getElementById('cv-matvec');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||760,h=360;
  c.width=w*2;c.height=h*2;c.style.height=h+'px';
  ctx.scale(2,2);

  const cx=w/2,cy=h/2,scale=40;
  // Easing
  const et=t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;

  // Background
  ctx.fillStyle='#1b1b2f';ctx.fillRect(0,0,w,h);

  // Grid
  ctx.strokeStyle='#2a2a4a';ctx.lineWidth=0.5;
  for(let i=-4;i<=4;i++){
    ctx.beginPath();ctx.moveTo(cx+i*scale,0);ctx.lineTo(cx+i*scale,h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,cy+i*scale);ctx.lineTo(w,cy+i*scale);ctx.stroke();
  }

  // Axes
  ctx.strokeStyle='#4a4a7a';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(0,cy);ctx.lineTo(w,cy);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx,0);ctx.lineTo(cx,h);ctx.stroke();

  // Vectors a=[1,1] and b=[2,0]
  const a=[1,1],b=[2,0];

  // Draw a (green)
  if(t<0.33){
    const at=Math.min(1,t/0.33);
    drawArrow(ctx,cx,cy,cx+a[0]*scale*at,cy-a[1]*scale*at,'#83c167',3,12);
    ctx.fillStyle='#83c167';ctx.font='bold 13px "Noto Sans TC"';
    ctx.fillText('a',cx+a[0]*scale*at+8,cy-a[1]*scale*at-8);
  }else{
    drawArrow(ctx,cx,cy,cx+a[0]*scale,cy-a[1]*scale,'#83c167',3,12);
    ctx.fillStyle='#83c167';ctx.font='bold 13px "Noto Sans TC"';
    ctx.fillText('a',cx+a[0]*scale+8,cy-a[1]*scale-8);
  }

  // Draw b (blue)
  if(t<0.66){
    const bt=Math.min(1,(t-0.33)/0.33);
    drawArrow(ctx,cx,cy,cx+b[0]*scale*bt,cy-b[1]*scale*bt,'#58c4dd',3,12);
    ctx.fillStyle='#58c4dd';ctx.font='bold 13px "Noto Sans TC"';
    ctx.fillText('b',cx+b[0]*scale*bt+8,cy-b[1]*scale*bt-8);
  }else{
    drawArrow(ctx,cx,cy,cx+b[0]*scale,cy-b[1]*scale,'#58c4dd',3,12);
    ctx.fillStyle='#58c4dd';ctx.font='bold 13px "Noto Sans TC"';
    ctx.fillText('b',cx+b[0]*scale+8,cy-b[1]*scale-8);
  }

  // Parallelogram guides and result (only at end)
  if(t>0.33){
    const cpt=Math.min(1,(t-0.33)/0.67);
    // Dashed parallelogram
    ctx.setLineDash([3,3]);ctx.strokeStyle='rgba(131,193,103,0.3)';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(cx+a[0]*scale,cy-a[1]*scale);
    ctx.lineTo(cx+(a[0]+b[0])*scale,cy-(a[1]+b[1])*scale);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx+b[0]*scale,cy-b[1]*scale);
    ctx.lineTo(cx+(a[0]+b[0])*scale,cy-(a[1]+b[1])*scale);ctx.stroke();
    ctx.setLineDash([]);

    // Result vector c=a+b (yellow)
    const c=[a[0]+b[0],a[1]+b[1]];
    drawArrow(ctx,cx,cy,cx+c[0]*scale*cpt,cy-c[1]*scale*cpt,'#ffff00',3.5,12);
    ctx.fillStyle='#ffff00';ctx.font='bold 13px "Noto Sans TC"';
    ctx.fillText('c=a+b',cx+c[0]*scale*cpt+8,cy-c[1]*scale*cpt-8);
  }

  // Continue or restart animation
  if(t>=1.5){ animMatvecState.t=0; }
  animMatvecState.animId=requestAnimationFrame(()=>animMatvecDraw(animMatvecState.t+=0.008));
}

// 2. Matrix Multiplication Animation (sec-72)
var animMatmulState={t:0,animId:null};
function animMatmulDraw(){
  const c=document.getElementById('cv-matmul');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||760,h=360;
  c.width=w*2;c.height=h*2;c.style.height=h+'px';
  ctx.scale(2,2);

  ctx.fillStyle='#1b1b2f';ctx.fillRect(0,0,w,h);

  const t=animMatmulState.t;
  // A=[1,2; 3,4], B=[2,0; 1,3], C=AB=[[4,6],[10,12]]
  const A=[[1,2],[3,4]],B=[[2,0],[1,3]],C=[[4,6],[10,12]];
  const cs=44; // cell size
  const axL=w*0.12, axT=h*0.28; // A top-left
  const bxL=w*0.38, bxT=h*0.28; // B top-left
  const cxL=w*0.65, cxT=h*0.28; // C top-left

  // Current step (cycle through 4 elements)
  const cycleLen=1.2; // seconds per element
  const totalCycle=cycleLen*4+1; // +1 pause
  const phase=t%totalCycle;
  const curEl=Math.min(3,Math.floor(phase/cycleLen));
  const elProgress=Math.min(1,(phase-curEl*cycleLen)/cycleLen);
  const row=Math.floor(curEl/2), col=curEl%2;

  // Draw matrix labels
  ctx.textAlign='center';
  ctx.font='bold 14px JetBrains Mono';
  ctx.fillStyle='#83c167';ctx.fillText('A',axL+cs,axT-16);
  ctx.fillStyle='#58c4dd';ctx.fillText('B',bxL+cs,bxT-16);
  ctx.fillStyle='#ffff00';ctx.fillText('C = AB',cxL+cs,cxT-16);

  // Helper: draw matrix
  function drawMat(vals,ox,oy,baseColor){
    for(let i=0;i<2;i++){
      for(let j=0;j<2;j++){
        const x=ox+j*cs,y=oy+i*cs;
        ctx.strokeStyle=baseColor;ctx.lineWidth=1.5;
        ctx.strokeRect(x,y,cs,cs);
        ctx.fillStyle=baseColor;ctx.font='16px JetBrains Mono';ctx.textAlign='center';
        ctx.fillText(vals[i][j],x+cs/2,y+cs/2+6);
      }
    }
  }

  // Draw A with row highlight
  for(let i=0;i<2;i++){
    for(let j=0;j<2;j++){
      const x=axL+j*cs,y=axT+i*cs;
      if(phase<cycleLen*4 && i===row){
        ctx.fillStyle='rgba(131,193,103,0.25)';ctx.fillRect(x,y,cs,cs);
      }
      ctx.strokeStyle='#83c167';ctx.lineWidth=1.5;ctx.strokeRect(x,y,cs,cs);
      ctx.fillStyle='#83c167';ctx.font='16px JetBrains Mono';ctx.textAlign='center';
      ctx.fillText(A[i][j],x+cs/2,y+cs/2+6);
    }
  }

  // Draw B with column highlight
  for(let i=0;i<2;i++){
    for(let j=0;j<2;j++){
      const x=bxL+j*cs,y=bxT+i*cs;
      if(phase<cycleLen*4 && j===col){
        ctx.fillStyle='rgba(88,196,221,0.25)';ctx.fillRect(x,y,cs,cs);
      }
      ctx.strokeStyle='#58c4dd';ctx.lineWidth=1.5;ctx.strokeRect(x,y,cs,cs);
      ctx.fillStyle='#58c4dd';ctx.font='16px JetBrains Mono';ctx.textAlign='center';
      ctx.fillText(B[i][j],x+cs/2,y+cs/2+6);
    }
  }

  // Draw C with progressive fill
  for(let i=0;i<2;i++){
    for(let j=0;j<2;j++){
      const x=cxL+j*cs,y=cxT+i*cs;
      const elIdx=i*2+j;
      if(elIdx<curEl||(elIdx===curEl&&elProgress>0.5)){
        ctx.fillStyle='rgba(255,255,0,0.2)';ctx.fillRect(x,y,cs,cs);
        ctx.fillStyle='#ffff00';ctx.font='bold 16px JetBrains Mono';ctx.textAlign='center';
        ctx.fillText(C[i][j],x+cs/2,y+cs/2+6);
      }
      ctx.strokeStyle='#ffff00';ctx.lineWidth=1.5;ctx.strokeRect(x,y,cs,cs);
    }
  }

  // Multiplication sign
  ctx.fillStyle='rgba(240,234,214,0.5)';ctx.font='24px JetBrains Mono';ctx.textAlign='center';
  ctx.fillText('×',axL+cs*2+20,axT+cs);
  ctx.fillText('=',bxL+cs*2+20,bxT+cs);

  // Show dot product computation
  if(phase<cycleLen*4){
    const a0=A[row][0],a1=A[row][1],b0=B[0][col],b1=B[1][col];
    const product=a0*b0+a1*b1;
    ctx.textAlign='left';ctx.font='14px JetBrains Mono';
    const ty=axT+cs*2+40;
    ctx.fillStyle='#83c167';ctx.fillText('Row '+(row+1)+' of A:  ['+a0+', '+a1+']',axL,ty);
    ctx.fillStyle='#58c4dd';ctx.fillText('Col '+(col+1)+' of B:  ['+b0+', '+b1+']',axL,ty+22);
    ctx.fillStyle='#e8b339';
    const dotStr=a0+'×'+b0+' + '+a1+'×'+b1+' = '+(a0*b0)+' + '+(a1*b1)+' = '+product;
    ctx.fillText('Dot product:  '+dotStr,axL,ty+48);
    ctx.fillStyle='#ffff00';ctx.font='bold 14px "Noto Sans TC"';
    ctx.fillText('C['+(row+1)+']['+(col+1)+'] = '+product,axL,ty+74);
  } else {
    ctx.textAlign='center';ctx.fillStyle='#e8b339';ctx.font='bold 14px "Noto Sans TC"';
    ctx.fillText('矩陣乘法完成！AB ≠ BA（不可交換）',w/2,axT+cs*2+60);
  }

  animMatmulState.animId=requestAnimationFrame(()=>{animMatmulState.t+=1/60;animMatmulDraw();});
}

// 3. Inverse Matrix Animation (sec-78)
var animInverseState={t:0,animId:null};
function animInverseDraw(t){
  const c=document.getElementById('cv-inverse');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||760,h=360;
  c.width=w*2;c.height=h*2;c.style.height=h+'px';
  ctx.scale(2,2);
  ctx.fillStyle='#1b1b2f';ctx.fillRect(0,0,w,h);

  const A=[[2,1],[0.5,2]];
  const det=A[0][0]*A[1][1]-A[0][1]*A[1][0];
  const Ainv=[[A[1][1]/det,-A[0][1]/det],[-A[1][0]/det,A[0][0]/det]];
  const cx0=w/2,cy0=h/2,sc=55;

  // Animation phases: 0-0.4 identity→A, 0.4-0.5 pause, 0.5-0.9 A→identity (via A⁻¹), 0.9-1.2 pause
  let frac=0, phase='';
  if(t<0.4){ frac=t/0.4; phase='forward'; }
  else if(t<0.5){ frac=1; phase='pause1'; }
  else if(t<0.9){ frac=(t-0.5)/0.4; phase='reverse'; }
  else { frac=0; phase='pause2'; }

  // Easing
  function ease(x){return x<0.5?2*x*x:1-Math.pow(-2*x+2,2)/2;}
  const ef=ease(frac);

  // Current interpolated matrix
  let M;
  if(phase==='forward'||phase==='pause1'){
    // I → A
    M=[[1+(A[0][0]-1)*ef, A[0][1]*ef],[A[1][0]*ef, 1+(A[1][1]-1)*ef]];
  } else {
    // A → I (applying A⁻¹)
    M=[[A[0][0]+(1-A[0][0])*ef, A[0][1]*(1-ef)],[A[1][0]*(1-ef), A[1][1]+(1-A[1][1])*ef]];
  }

  // Draw transformed grid lines
  ctx.lineWidth=0.6;
  for(let i=-4;i<=4;i++){
    // Vertical grid line: x=i, y varies
    ctx.strokeStyle='rgba(88,196,221,0.15)';
    ctx.beginPath();
    for(let j=-4;j<=4;j+=0.2){
      const tx=M[0][0]*i+M[0][1]*j, ty=M[1][0]*i+M[1][1]*j;
      const px=cx0+tx*sc, py=cy0-ty*sc;
      j===-4?ctx.moveTo(px,py):ctx.lineTo(px,py);
    }
    ctx.stroke();
    // Horizontal grid line: y=i, x varies
    ctx.beginPath();
    for(let j=-4;j<=4;j+=0.2){
      const tx=M[0][0]*j+M[0][1]*i, ty=M[1][0]*j+M[1][1]*i;
      const px=cx0+tx*sc, py=cy0-ty*sc;
      j===-4?ctx.moveTo(px,py):ctx.lineTo(px,py);
    }
    ctx.stroke();
  }

  // Draw unit square being transformed
  const sq=[[0,0],[1,0],[1,1],[0,1]];
  ctx.fillStyle='rgba(131,193,103,0.15)';
  ctx.beginPath();
  sq.forEach((p,i)=>{
    const tx=M[0][0]*p[0]+M[0][1]*p[1], ty=M[1][0]*p[0]+M[1][1]*p[1];
    const px=cx0+tx*sc, py=cy0-ty*sc;
    i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
  });
  ctx.closePath();ctx.fill();
  ctx.strokeStyle='#83c167';ctx.lineWidth=2;ctx.stroke();

  // Draw transformed basis vectors
  const e1t=[M[0][0],M[1][0]], e2t=[M[0][1],M[1][1]];
  // e1
  ctx.strokeStyle='#fc6255';ctx.lineWidth=2.5;
  ctx.beginPath();ctx.moveTo(cx0,cy0);ctx.lineTo(cx0+e1t[0]*sc,cy0-e1t[1]*sc);ctx.stroke();
  // arrowhead e1
  const a1=Math.atan2(-e1t[1],e1t[0]);
  ctx.fillStyle='#fc6255';ctx.beginPath();
  ctx.moveTo(cx0+e1t[0]*sc,cy0-e1t[1]*sc);
  ctx.lineTo(cx0+e1t[0]*sc-8*Math.cos(a1-0.35),cy0-e1t[1]*sc+8*Math.sin(a1-0.35));
  ctx.lineTo(cx0+e1t[0]*sc-8*Math.cos(a1+0.35),cy0-e1t[1]*sc+8*Math.sin(a1+0.35));
  ctx.fill();
  // e2
  ctx.strokeStyle='#58c4dd';ctx.lineWidth=2.5;
  ctx.beginPath();ctx.moveTo(cx0,cy0);ctx.lineTo(cx0+e2t[0]*sc,cy0-e2t[1]*sc);ctx.stroke();
  const a2=Math.atan2(-e2t[1],e2t[0]);
  ctx.fillStyle='#58c4dd';ctx.beginPath();
  ctx.moveTo(cx0+e2t[0]*sc,cy0-e2t[1]*sc);
  ctx.lineTo(cx0+e2t[0]*sc-8*Math.cos(a2-0.35),cy0-e2t[1]*sc+8*Math.sin(a2-0.35));
  ctx.lineTo(cx0+e2t[0]*sc-8*Math.cos(a2+0.35),cy0-e2t[1]*sc+8*Math.sin(a2+0.35));
  ctx.fill();

  // Scatter some transformed points to show mapping
  ctx.globalAlpha=0.5;
  const pts=[[1,0],[0,1],[-1,0],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1],[0.5,0.5]];
  pts.forEach(p=>{
    const tx=M[0][0]*p[0]+M[0][1]*p[1], ty=M[1][0]*p[0]+M[1][1]*p[1];
    ctx.fillStyle='#ffff00';ctx.beginPath();ctx.arc(cx0+tx*sc,cy0-ty*sc,2.5,0,Math.PI*2);ctx.fill();
  });
  ctx.globalAlpha=1;

  // Labels
  ctx.textAlign='center';ctx.font='bold 13px "Noto Sans TC"';
  if(phase==='forward'){
    ctx.fillStyle='#83c167';ctx.fillText('正在套用 A 變換...',cx0,24);
  } else if(phase==='pause1'){
    ctx.fillStyle='#83c167';ctx.fillText('變換後 (A·x)',cx0,24);
  } else if(phase==='reverse'){
    ctx.fillStyle='#e8b339';ctx.fillText('正在套用 A⁻¹ 還原...',cx0,24);
  } else {
    ctx.fillStyle='#58c4dd';ctx.fillText('還原完成！A⁻¹A = I',cx0,24);
  }

  // Matrix display
  ctx.font='12px "JetBrains Mono"';ctx.textAlign='left';
  ctx.fillStyle='#fc6255';ctx.fillText('e₁',cx0+e1t[0]*sc+6,cy0-e1t[1]*sc-4);
  ctx.fillStyle='#58c4dd';ctx.fillText('e₂',cx0+e2t[0]*sc+6,cy0-e2t[1]*sc-4);

  // Show A and A⁻¹ info
  ctx.fillStyle='#c8c0b0';ctx.font='11px "JetBrains Mono"';ctx.textAlign='left';
  ctx.fillText('A = [[2, 1], [0.5, 2]]',10,h-30);
  ctx.fillText('A⁻¹ ≈ [[0.57, -0.29], [-0.14, 0.57]]',10,h-14);
  ctx.fillStyle='rgba(200,192,176,0.4)';
  ctx.fillText('det(A) = '+det.toFixed(1),w-130,h-14);

  if(t>=1.2){ animInverseState.t=0; }
  animInverseState.animId=requestAnimationFrame(()=>animInverseDraw(animInverseState.t+=0.008));
}

// 4. Symmetric Matrix Animation (sec-83)
var animSymmState={t:0,animId:null};
function animSymmDraw(t){
  const c=document.getElementById('cv-symm');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||760,h=360;
  c.width=w*2;c.height=h*2;c.style.height=h+'px';
  ctx.scale(2,2);

  ctx.fillStyle='#1b1b2f';ctx.fillRect(0,0,w,h);

  // A = [[2,1],[1,2]], eigenvalues 3, 1, eigenvectors (1,1)/√2 and (-1,1)/√2
  const A=[[2,1],[1,2]];
  const ev1=[1/Math.sqrt(2),1/Math.sqrt(2)],ev2=[-1/Math.sqrt(2),1/Math.sqrt(2)];
  const cx=w/2,cy=h/2,scale=60;

  // Grid
  ctx.strokeStyle='#2a2a4a';ctx.lineWidth=0.5;
  for(let i=-2;i<=2;i++){
    ctx.beginPath();ctx.moveTo(cx+i*scale,0);ctx.lineTo(cx+i*scale,h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,cy+i*scale);ctx.lineTo(w,cy+i*scale);ctx.stroke();
  }

  // Axes
  ctx.strokeStyle='#4a4a7a';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(0,cy);ctx.lineTo(w,cy);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx,0);ctx.lineTo(cx,h);ctx.stroke();

  // Transform random vectors
  const n=8;
  for(let i=0;i<n;i++){
    const ang=i*Math.PI*2/n;
    const v=[Math.cos(ang),Math.sin(ang)];
    const av=[A[0][0]*v[0]+A[0][1]*v[1],A[1][0]*v[0]+A[1][1]*v[1]];
    const avt=[av[0]*(0.5+0.5*t),av[1]*(0.5+0.5*t)];

    // Check if eigenvector
    const isEig=Math.abs(v[0]*ev1[0]+v[1]*ev1[1])>0.9||Math.abs(v[0]*ev2[0]+v[1]*ev2[1])>0.9;
    const color=isEig?'#ffff00':'#83c167';

    drawArrow(ctx,cx,cy,cx+avt[0]*scale,cy-avt[1]*scale,color,2,10);
  }

  // Draw eigenvector directions (dashed)
  ctx.setLineDash([4,3]);ctx.strokeStyle='#ffff00';ctx.lineWidth=2;
  ctx.beginPath();ctx.moveTo(cx-ev1[0]*100,cy+ev1[1]*100);ctx.lineTo(cx+ev1[0]*100,cy-ev1[1]*100);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx-ev2[0]*100,cy+ev2[1]*100);ctx.lineTo(cx+ev2[0]*100,cy-ev2[1]*100);ctx.stroke();
  ctx.setLineDash([]);

  // Right angle marker
  const len=15;
  ctx.strokeStyle='#ffff00';ctx.lineWidth=1.5;
  const p1=[cx+ev1[0]*len,cy-ev1[1]*len];
  const p2=[cx+ev1[0]*len+ev2[0]*len,cy-ev1[1]*len-ev2[1]*len];
  const p3=[cx+ev2[0]*len,cy-ev2[1]*len];
  ctx.beginPath();ctx.moveTo(p1[0],p1[1]);ctx.lineTo(p2[0],p2[1]);ctx.lineTo(p3[0],p3[1]);ctx.stroke();

  if(t>=1.5){ animSymmState.t=0; }
  animSymmState.animId=requestAnimationFrame(()=>animSymmDraw(animSymmState.t+=0.008));
}

// 5. Diagonalization Animation (sec-diag)
var animDiagState={t:0,animId:null};
function animDiagDraw(t){
  const c=document.getElementById('cv-diag');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||760,h=360;
  c.width=w*2;c.height=h*2;c.style.height=h+'px';
  ctx.scale(2,2);

  ctx.fillStyle='#1b1b2f';ctx.fillRect(0,0,w,h);

  // A = [[1,4],[1,1]], λ₁=3, λ₂=-1, P=[[2,-2],[1,1]]
  const A=[[1,4],[1,1]];
  const cx1=w/3,cy=h/2,cx2=2*w/3,scale=50;

  // Grid for both sides
  for(let cx of [cx1,cx2]){
    ctx.strokeStyle='#2a2a4a';ctx.lineWidth=0.5;
    for(let i=-2;i<=2;i++){
      ctx.beginPath();ctx.moveTo(cx+i*scale,0);ctx.lineTo(cx+i*scale,h);ctx.stroke();
      ctx.beginPath();ctx.moveTo(0,cy+i*scale);ctx.lineTo(w,cy+i*scale);ctx.stroke();
    }
    ctx.strokeStyle='#4a4a7a';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(0,cy);ctx.lineTo(w,cy);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx,0);ctx.lineTo(cx,h);ctx.stroke();
  }

  // Left: standard basis e1, e2 transformed by A
  const e1=[1,0],e2=[0,1];
  const ae1=[A[0][0]*e1[0]+A[0][1]*e1[1],A[1][0]*e1[0]+A[1][1]*e1[1]];
  const ae2=[A[0][0]*e2[0]+A[0][1]*e2[1],A[1][0]*e2[0]+A[1][1]*e2[1]];

  drawArrow(ctx,cx1,cy,cx1+ae1[0]*scale*t,cy-ae1[1]*scale*t,'#83c167',3,12);
  drawArrow(ctx,cx1,cy,cx1+ae2[0]*scale*t,cy-ae2[1]*scale*t,'#fc6255',3,12);

  ctx.fillStyle='#83c167';ctx.font='11px "Noto Sans TC"';
  ctx.fillText('A·e₁',cx1+ae1[0]*scale*t+6,cy-ae1[1]*scale*t-6);
  ctx.fillStyle='#fc6255';
  ctx.fillText('A·e₂',cx1+ae2[0]*scale*t+6,cy-ae2[1]*scale*t-6);

  ctx.fillStyle='rgba(200,192,176,0.5)';ctx.font='12px "Noto Sans TC"';ctx.textAlign='center';
  ctx.fillText('原始座標',cx1,cy-130);

  // Right: eigenvector basis (just scales)
  const p1=[2,1],p2=[-2,1];
  const sp1=[3,0],sp2=[0,-1]; // eigenvalue scaling

  drawArrow(ctx,cx2,cy,cx2+sp1[0]*scale*t,cy-sp1[1]*scale*t,'#83c167',3,12);
  drawArrow(ctx,cx2,cy,cx2+sp2[0]*scale*t,cy-sp2[1]*scale*t,'#fc6255',3,12);

  ctx.fillStyle='#83c167';ctx.font='11px "Noto Sans TC"';
  ctx.fillText('3·p₁',cx2+sp1[0]*scale*t+6,cy-sp1[1]*scale*t-6);
  ctx.fillStyle='#fc6255';
  ctx.fillText('-1·p₂',cx2+sp2[0]*scale*t+6,cy-sp2[1]*scale*t-6);

  ctx.fillStyle='rgba(200,192,176,0.5)';ctx.textAlign='center';
  ctx.fillText('特徵向量座標',cx2,cy-130);

  if(t>=1.5){ animDiagState.t=0; }
  animDiagState.animId=requestAnimationFrame(()=>animDiagDraw(animDiagState.t+=0.008));
}

// 6. Quadratic Form Animation (sec-qf)
var animQfState={t:0,animId:null};
function animQfDraw(t){
  const c=document.getElementById('cv-qf');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.clientWidth||760,h=360;
  c.width=w*2;c.height=h*2;c.style.height=h+'px';
  ctx.scale(2,2);
  ctx.fillStyle='#1b1b2f';ctx.fillRect(0,0,w,h);

  // Q(x) = 5x₁² + 8x₁x₂ + 5x₂²  ⟹  A=[[5,4],[4,5]]
  // Eigenvalues: λ₁=9, λ₂=1
  // Eigenvectors: v₁=[1,1]/√2 (45°), v₂=[-1,1]/√2 (135°)
  // Level curve Q(x)=c is ellipse: 9y₁²+y₂²=c in eigenbasis
  const lam1=9, lam2=1;
  const eigAngle=Math.PI/4; // 45 degrees for v₁=[1,1]/√2
  const cx0=w/2, cy0=h/2, sc=55;

  // Animation: 0→0.5 show tilted ellipse, 0.5→1.0 rotate to align with axes
  const phase=Math.min(t/1.0,1);
  function ease(x){return x<0.5?2*x*x:1-Math.pow(-2*x+2,2)/2;}
  const rotProg=t<0.4?0: t<0.9?ease((t-0.4)/0.5): 1;
  const curAngle=eigAngle*(1-rotProg); // starts tilted, ends axis-aligned

  // Draw grid
  ctx.strokeStyle='#2a2a4a';ctx.lineWidth=0.5;
  for(let i=-4;i<=4;i++){
    ctx.beginPath();ctx.moveTo(cx0+i*sc,0);ctx.lineTo(cx0+i*sc,h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,cy0+i*sc);ctx.lineTo(w,cy0+i*sc);ctx.stroke();
  }
  ctx.strokeStyle='#4a4a7a';ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(0,cy0);ctx.lineTo(w,cy0);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx0,0);ctx.lineTo(cx0,h);ctx.stroke();

  // Draw level-curve ellipses at different c values
  const levels=[3,6,10,15];
  const colors=['rgba(131,193,103,0.3)','rgba(131,193,103,0.45)','rgba(131,193,103,0.6)','rgba(131,193,103,0.75)'];
  const n=120;
  levels.forEach((cv,li)=>{
    // In eigenbasis: lam1*y1² + lam2*y2² = cv  →  y1=√(cv/lam1)cosθ, y2=√(cv/lam2)sinθ
    const a=Math.sqrt(cv/lam1); // semi-axis along v₁ (short axis since lam1=9)
    const b=Math.sqrt(cv/lam2); // semi-axis along v₂ (long axis since lam2=1)
    ctx.strokeStyle=colors[li];ctx.lineWidth=li===levels.length-1?2.5:1.5;
    ctx.beginPath();
    for(let i=0;i<=n;i++){
      const theta=i*Math.PI*2/n;
      // Point in eigenbasis
      const y1=a*Math.cos(theta), y2=b*Math.sin(theta);
      // Rotate by current angle back to x-coords
      const x=y1*Math.cos(curAngle)-y2*Math.sin(curAngle);
      const y=y1*Math.sin(curAngle)+y2*Math.cos(curAngle);
      const px=cx0+x*sc, py=cy0-y*sc;
      i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
    }
    ctx.closePath();ctx.stroke();

    // Fill innermost ellipse
    if(li===0){ctx.fillStyle='rgba(131,193,103,0.08)';ctx.fill();}
  });

  // Draw principal axes (eigenvectors)
  ctx.setLineDash([5,4]);ctx.lineWidth=1.8;
  // v₁ direction (short axis of ellipse)
  const dx1=Math.cos(curAngle)*140, dy1=Math.sin(curAngle)*140;
  ctx.strokeStyle='#fc6255';
  ctx.beginPath();ctx.moveTo(cx0-dx1,cy0+dy1);ctx.lineTo(cx0+dx1,cy0-dy1);ctx.stroke();
  // v₂ direction (long axis of ellipse)
  const dx2=Math.cos(curAngle+Math.PI/2)*140, dy2=Math.sin(curAngle+Math.PI/2)*140;
  ctx.strokeStyle='#58c4dd';
  ctx.beginPath();ctx.moveTo(cx0-dx2,cy0+dy2);ctx.lineTo(cx0+dx2,cy0-dy2);ctx.stroke();
  ctx.setLineDash([]);

  // Eigenvector arrowheads and labels
  ctx.font='bold 12px "JetBrains Mono"';
  // v₁
  ctx.fillStyle='#fc6255';
  const ev1x=cx0+Math.cos(curAngle)*80, ev1y=cy0-Math.sin(curAngle)*80;
  ctx.beginPath();ctx.arc(ev1x,ev1y,4,0,Math.PI*2);ctx.fill();
  ctx.fillText('v₁ (λ=9)',ev1x+8,ev1y-8);
  // v₂
  ctx.fillStyle='#58c4dd';
  const ev2x=cx0+Math.cos(curAngle+Math.PI/2)*80, ev2y=cy0-Math.sin(curAngle+Math.PI/2)*80;
  ctx.beginPath();ctx.arc(ev2x,ev2y,4,0,Math.PI*2);ctx.fill();
  ctx.fillText('v₂ (λ=1)',ev2x+8,ev2y-8);

  // Semi-axis length indicators on the outermost ellipse
  const outerC=levels[levels.length-1];
  const outerA=Math.sqrt(outerC/lam1), outerB=Math.sqrt(outerC/lam2);
  // Short semi-axis length along v₁
  ctx.fillStyle='rgba(252,98,85,0.6)';ctx.font='11px "JetBrains Mono"';
  const sa1x=cx0+outerA*Math.cos(curAngle)*sc, sa1y=cy0-outerA*Math.sin(curAngle)*sc;
  ctx.fillText('a=√(c/λ₁)≈'+outerA.toFixed(2),sa1x+6,sa1y+16);
  // Long semi-axis length along v₂
  ctx.fillStyle='rgba(88,196,221,0.6)';
  const sa2x=cx0+outerB*Math.cos(curAngle+Math.PI/2)*sc, sa2y=cy0-outerB*Math.sin(curAngle+Math.PI/2)*sc;
  ctx.fillText('b=√(c/λ₂)≈'+outerB.toFixed(2),sa2x+6,sa2y-6);

  // Title text
  ctx.textAlign='center';ctx.font='bold 13px "Noto Sans TC"';
  if(rotProg<0.05){
    ctx.fillStyle='#83c167';ctx.fillText('Q(x) = 5x₁² + 8x₁x₂ + 5x₂² 的等高線（傾斜橢圓）',cx0,24);
  } else if(rotProg<1){
    ctx.fillStyle='#e8b339';ctx.fillText('旋轉至特徵向量座標...消除交叉項',cx0,24);
  } else {
    ctx.fillStyle='#58c4dd';ctx.fillText('特徵向量座標：Q = 9y₁² + y₂²（標準橢圓）',cx0,24);
  }

  // Info at bottom
  ctx.textAlign='left';ctx.font='11px "JetBrains Mono"';ctx.fillStyle='#c8c0b0';
  ctx.fillText('A = [[5,4],[4,5]]   λ₁=9, λ₂=1',10,h-14);
  ctx.fillStyle='rgba(200,192,176,0.4)';
  ctx.fillText('v₁=[1,1]/√2   v₂=[-1,1]/√2',w-220,h-14);

  if(t>=1.4){ animQfState.t=0; }
  animQfState.animId=requestAnimationFrame(()=>animQfDraw(animQfState.t+=0.006));
}

// ===== 3-STORY BUILDING MODAL ANALYSIS =====
var bldgAnimState={animId:null,t:0};

function bldgSolve3x3(m,k){
  // Stiffness matrix K for 3-story shear building
  // K = k*[[2,-1,0],[-1,2,-1],[0,-1,1]]
  // Eigenvalue problem: (1/m)*K * phi = omega^2 * phi
  var r=k/m;
  var K=[[2*r,-r,0],[-r,2*r,-r],[0,-r,r]];

  // Solve 3x3 eigenvalue analytically using characteristic polynomial
  // det(K - lambda*I) = 0
  // For K/m matrix with k/m=r: eigenvalues of [[2r,-r,0],[-r,2r,-r],[0,-r,r]]
  // Characteristic: -λ³ + 5rλ² - 6r²λ + r³ = 0  → λ³ - 5rλ² + 6r²λ - r³ = 0
  // Use numerical approach (Jacobi iteration for symmetric matrix)
  var A=[[K[0][0],K[0][1],K[0][2]],[K[1][0],K[1][1],K[1][2]],[K[2][0],K[2][1],K[2][2]]];
  var V=[[1,0,0],[0,1,0],[0,0,1]]; // eigenvectors

  // Jacobi eigenvalue algorithm (symmetric 3x3)
  for(var iter=0;iter<100;iter++){
    // Find largest off-diagonal
    var maxVal=0,p=0,q=1;
    for(var i=0;i<3;i++)for(var j=i+1;j<3;j++){
      if(Math.abs(A[i][j])>maxVal){maxVal=Math.abs(A[i][j]);p=i;q=j;}
    }
    if(maxVal<1e-12) break;

    // Compute rotation
    var theta=0;
    if(Math.abs(A[p][p]-A[q][q])<1e-14) theta=Math.PI/4;
    else theta=0.5*Math.atan2(2*A[p][q],A[p][p]-A[q][q]);
    var cs=Math.cos(theta),sn=Math.sin(theta);

    // Rotate A
    var Ap=[[0,0,0],[0,0,0],[0,0,0]];
    for(var i=0;i<3;i++)for(var j=0;j<3;j++) Ap[i][j]=A[i][j];
    for(var i=0;i<3;i++){
      Ap[i][p]=A[i][p]*cs+A[i][q]*sn;
      Ap[i][q]=-A[i][p]*sn+A[i][q]*cs;
    }
    for(var j=0;j<3;j++){
      A[p][j]=Ap[p][j]*cs+Ap[q][j]*sn;
      A[q][j]=-Ap[p][j]*sn+Ap[q][j]*cs;
    }
    // fix symmetry
    for(var i=0;i<3;i++)for(var j=i+1;j<3;j++){A[j][i]=A[i][j];}
    A[p][q]=0;A[q][p]=0;

    // Rotate V
    for(var i=0;i<3;i++){
      var vp=V[i][p],vq=V[i][q];
      V[i][p]=vp*cs+vq*sn;
      V[i][q]=-vp*sn+vq*cs;
    }
  }

  // Extract eigenvalues and eigenvectors, sort ascending
  var eigs=[];
  for(var i=0;i<3;i++){
    var vec=[V[0][i],V[1][i],V[2][i]];
    var len=Math.hypot(vec[0],vec[1],vec[2]);
    if(len>1e-10){vec[0]/=len;vec[1]/=len;vec[2]/=len;}
    // Ensure first component positive for consistency
    if(vec[0]<0){vec[0]*=-1;vec[1]*=-1;vec[2]*=-1;}
    eigs.push({val:Math.max(0,A[i][i]),vec:vec});
  }
  eigs.sort(function(a,b){return a.val-b.val;});
  return eigs;
}

function bldgUpdate(){
  var mSlider=document.getElementById('bldg-m');
  var kSlider=document.getElementById('bldg-k');
  if(!mSlider||!kSlider)return;
  var m=parseFloat(mSlider.value)||1;
  var k=parseFloat(kSlider.value)||1;
  document.getElementById('bldg-m-val').textContent=m.toFixed(1);
  document.getElementById('bldg-k-val').textContent=k.toFixed(1);

  var eigs=bldgSolve3x3(m,k);
  bldgAnimState.eigs=eigs;
  bldgAnimState.m=m;
  bldgAnimState.k=k;
  bldgAnimState.t=0;
  if(!bldgAnimState.animId) bldgDraw();

  // Update info box
  var info=document.getElementById('bldg-info');
  if(info){
    var txt='<div style="font-size:13px;line-height:1.8">';
    txt+='<div style="font-weight:700;color:#ffff00;margin-bottom:4px">剛度矩陣 K（÷m 後的特徵值問題）</div>';
    var r=k/m;
    txt+='<div style="color:#c8c0b0;font-size:12px;font-family:JetBrains Mono">';
    txt+='K/m = [['+( 2*r).toFixed(2)+', '+ (-r).toFixed(2)+', 0], ['+ (-r).toFixed(2)+', '+(2*r).toFixed(2)+', '+(-r).toFixed(2)+'], [0, '+(-r).toFixed(2)+', '+(r).toFixed(2)+']]</div>';
    txt+='<div style="margin-top:8px;display:flex;gap:10px;flex-wrap:wrap">';
    var cols=['#fc6255','#58c4dd','#83c167'];
    var names=['第一模態（同向搖擺）','第二模態（中間反向）','第三模態（交替反向）'];
    for(var i=0;i<3;i++){
      var omega=Math.sqrt(eigs[i].val);
      var freq=omega/(2*Math.PI);
      txt+='<div style="background:rgba(255,255,255,0.04);border:1px solid '+cols[i]+'40;padding:6px 10px;border-radius:4px;flex:1;min-width:160px">';
      txt+='<div style="color:'+cols[i]+';font-weight:700;font-size:13px">'+names[i]+'</div>';
      txt+='<div style="font-family:JetBrains Mono;font-size:11px;color:#c8c0b0;margin-top:2px">';
      txt+='λ = ω² = '+eigs[i].val.toFixed(3)+'<br>';
      txt+='ω = '+omega.toFixed(3)+' rad/s<br>';
      txt+='f = '+freq.toFixed(3)+' Hz</div>';
      txt+='<div style="font-family:JetBrains Mono;font-size:10px;color:rgba(200,192,176,0.5);margin-top:2px">';
      txt+='φ = ['+eigs[i].vec[0].toFixed(2)+', '+eigs[i].vec[1].toFixed(2)+', '+eigs[i].vec[2].toFixed(2)+']</div>';
      txt+='</div>';
    }
    txt+='</div></div>';
    info.innerHTML=txt;
  }
}

function bldgDraw(){
  var c=document.getElementById('bldg-canvas'); if(!c)return;
  var ctx=c.getContext('2d');
  var w=c.clientWidth||760, h=420;
  c.width=w*2; c.height=h*2; c.style.height=h+'px'; ctx.scale(2,2);
  ctx.fillStyle='#1b1b2f'; ctx.fillRect(0,0,w,h);

  var eigs=bldgAnimState.eigs;
  if(!eigs||eigs.length<3){bldgAnimState.animId=requestAnimationFrame(bldgDraw);return;}

  bldgAnimState.t+=0.016;
  var t=bldgAnimState.t;

  var cols=['#fc6255','#58c4dd','#83c167'];
  var modeNames=['Mode 1','Mode 2','Mode 3'];

  // Layout: 4 columns — static building + 3 modes
  var colW=w/4;
  var groundY=h-50;
  var floorH=70;
  var bldgW=50;

  // --- Helper: draw building at column cx with floor displacements ---
  function drawBuilding(cx,displacements,color,label,freqLabel,modeVec){
    var d=displacements; // [floor1, floor2, floor3] horizontal offsets

    // Ground
    ctx.strokeStyle='#555'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(cx-40,groundY); ctx.lineTo(cx+40,groundY); ctx.stroke();
    // Ground hatching
    ctx.strokeStyle='#444'; ctx.lineWidth=0.8;
    for(var i=-35;i<=35;i+=7){
      ctx.beginPath(); ctx.moveTo(cx+i,groundY); ctx.lineTo(cx+i-5,groundY+8); ctx.stroke();
    }

    // Springs between floors (zigzag)
    for(var f=0;f<3;f++){
      var baseY=groundY-f*floorH;
      var topY=groundY-(f+1)*floorH;
      var baseX=cx+(f>0?d[f-1]:0);
      var topX=cx+d[f];

      // Left spring
      ctx.strokeStyle='rgba(232,179,57,0.4)'; ctx.lineWidth=1;
      var sx=baseX-bldgW/2, ex=topX-bldgW/2;
      var steps=8;
      ctx.beginPath();
      for(var s=0;s<=steps;s++){
        var frac=s/steps;
        var py=baseY+(topY-baseY)*frac;
        var px=sx+(ex-sx)*frac + (s%2===0?0:(s%4===1?5:-5));
        s===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
      }
      ctx.stroke();

      // Right spring
      sx=baseX+bldgW/2; ex=topX+bldgW/2;
      ctx.beginPath();
      for(var s=0;s<=steps;s++){
        var frac=s/steps;
        var py=baseY+(topY-baseY)*frac;
        var px=sx+(ex-sx)*frac + (s%2===0?0:(s%4===1?5:-5));
        s===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
      }
      ctx.stroke();
    }

    // Floor slabs (rectangles) — draw from bottom to top
    for(var f=0;f<3;f++){
      var fy=groundY-(f+1)*floorH;
      var fx=cx+d[f];
      // Slab
      ctx.fillStyle=color+'30';
      ctx.strokeStyle=color; ctx.lineWidth=2;
      ctx.fillRect(fx-bldgW/2,fy-6,bldgW,12);
      ctx.strokeRect(fx-bldgW/2,fy-6,bldgW,12);

      // Mass label
      ctx.fillStyle=color; ctx.font='bold 10px "JetBrains Mono"'; ctx.textAlign='center';
      ctx.fillText('m',fx,fy+3);

      // Floor number
      ctx.fillStyle='rgba(200,192,176,0.4)'; ctx.font='9px "Noto Sans TC"';
      ctx.fillText((f+1)+'F',fx+bldgW/2+12,fy+3);
    }

    // Mode label
    ctx.fillStyle=color; ctx.font='bold 13px "JetBrains Mono"'; ctx.textAlign='center';
    ctx.fillText(label,cx,28);

    // Frequency
    if(freqLabel){
      ctx.font='11px "JetBrains Mono"'; ctx.fillStyle=color+'cc';
      ctx.fillText(freqLabel,cx,44);
    }

    // Mode shape vector text
    if(modeVec){
      ctx.font='9px "JetBrains Mono"'; ctx.fillStyle='rgba(200,192,176,0.4)';
      ctx.fillText('φ=['+modeVec[0].toFixed(2)+','+modeVec[1].toFixed(2)+','+modeVec[2].toFixed(2)+']',cx,groundY+18);
    }
  }

  // --- Column 0: Static building ---
  drawBuilding(colW*0.5,[0,0,0],'#888','靜態建築',null,null);
  ctx.fillStyle='rgba(200,192,176,0.3)'; ctx.font='10px "Noto Sans TC"'; ctx.textAlign='center';
  ctx.fillText('原始位置',colW*0.5,groundY+18);

  // --- Columns 1-3: Three modes vibrating ---
  var amp=30; // max amplitude in pixels
  for(var mode=0;mode<3;mode++){
    var omega=Math.sqrt(eigs[mode].val);
    var phi=eigs[mode].vec;
    // Normalize mode shape so max component = 1
    var maxPhi=Math.max(Math.abs(phi[0]),Math.abs(phi[1]),Math.abs(phi[2]));
    if(maxPhi<1e-10) maxPhi=1;
    var normPhi=[phi[0]/maxPhi, phi[1]/maxPhi, phi[2]/maxPhi];

    // Displacement = amplitude * phi * sin(omega*t)
    var phase=Math.sin(omega*t);
    var disp=[normPhi[0]*amp*phase, normPhi[1]*amp*phase, normPhi[2]*amp*phase];

    var freqStr='ω='+omega.toFixed(2)+' rad/s';
    drawBuilding(colW*(mode+1.5), disp, cols[mode], modeNames[mode], freqStr, normPhi);
  }

  // --- Title ---
  ctx.fillStyle='#c8c0b0'; ctx.font='bold 13px "Noto Sans TC"'; ctx.textAlign='center';
  ctx.fillText('三層樓建築模態分析 — 特徵值 = ω²，特徵向量 = 振型',w/2,h-18);

  // Arrow labels connecting eigenvalue concept
  ctx.fillStyle='rgba(255,255,0,0.5)'; ctx.font='10px "Noto Sans TC"'; ctx.textAlign='center';
  ctx.fillText('Kφ = ω²Mφ  →  特徵值問題！',w/2,h-4);

  bldgAnimState.animId=requestAnimationFrame(bldgDraw);
}

// Initialize on load
window.onload=function(){
  renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'\\(',right:'\\)',display:false}],throwOnError:false});
  calcTranspose();calcMul();
  if(document.getElementById('det2-in'))calcDet2();
  if(document.getElementById('det3-in'))calcDet3();
  if(document.getElementById('inv2-in'))calcInv2();
  if(document.getElementById('eig2-in'))calcEig2();
  // If URL has hash, navigate to that section
  const hash=location.hash.replace('#','');
  if(hash&&document.getElementById(hash)){
    go(hash);
  } else {
    // Init canvases only in active section (hidden sections have 0 dimensions)
    const activeSec=document.querySelector('.section.active');
    if(activeSec)initCanvasesInSection(activeSec);
  }
};
</script>
</body></html>
